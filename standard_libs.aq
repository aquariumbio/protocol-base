{"config":{"title":"standard_libs","description":"No description given","copyright":"No copyright declared","version":"no version info","authors":[],"maintainer":{"name":"No maintainer","email":"noone@nowehere"},"acknowledgements":[],"github":{"repo":"none","user":"none","access_token":"none"},"keywords":[],"aquadoc_version":"1.0.2"},"components":[{"library":{"name":"Add Output","category":"Standard Libs","code_source":"module AddOutput\n    \n## Example\n        # operations.each do |op|\n        #     add_output op,\"Media\", \"YEB medium\", ObjectType\"200 mL Liquid\"\n        # end\n        #operations.make\n\n    def add_output operation, output_name, sample, container\n    ft = FieldType.new(\n                name: output_name,\n                ftype: \"sample\",\n                parent_class: \"OperationType\",\n                parent_id: nil\n            )\n            ft.save\n        \n            aft = AllowableFieldType.new({\n                field_type_id: ft.id,\n                sample_type_id: sample.sample_type.id,\n                object_type_id: ObjectType.find_by_name(container).id\n            })\n            aft.save\n            \n            fv = FieldValue.new(\n                name: \"Media\",\n                child_item_id: nil,\n                child_sample_id: sample.id,\n                role: 'output',\n                parent_class: \"Operation\",\n                parent_id: operation.id,\n                field_type_id: ft.id)\n            fv.allowable_field_type_id = aft.id\n            fv.save\n        \n    end\n\nend"}},{"library":{"name":"AssociationManagement","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\n# Module with methods and classes that seek to help with associating data\n# to, and retrieving data from, items, operations, plans, collections, and parts.\n#\nmodule AssociationManagement\n  require 'matrix'\n\n  # Associates a key and value to the associations hash of the given object.\n  # Replaces an existing association for the given key.\n  #\n  # A part may be represented as a part item, or a collection and coordinate.\n  #\n  # @param object [DataAssociator]  the object to associate data\n  # @param key [String]  the key for the association\n  # @param data [serializable object]  the data for the association\n  # @param opts [Hash]  additional method options\n  # @option coord [Array]  row, column pair if the object is a collection\n  # @option data_matrix [String]  optional data matrix for a collection\n  def associate_data(object, key, data, opts = {})\n    AssociationMap.associate_data(object, key, data, opts)\n  end\n\n  # Returns the associated value from the associations hash of a given object.\n  # If an association doesn't exist for the key, returns nil.\n  #\n  # @param object [DataAssociator]  the object to associated data\n  # @param key [String]  the key for the association\n  # @param opts [Hash]  additional method options\n  # @option coord [tuple Array]  row, column of part if object is a collection.\n  # @option data_matrix [String]  optional data matrix\n  # @return [serializable object]  the value associated with the given key\n  def get_associated_data(object, key, opts = {})\n    AssociationMap.get_associated_data(object, key, opts)\n  end\n\n  # Defines a map to manage the associations for an {Item}, {Operation}, or\n  # {Plan} object, which are Aquarium classes that extend {DataAssociator}.\n  #\n  # Note: if `map` contains associations, it is necessary to call `map.save` for\n  #       the associations to be saved to Aquarium.\n  #\n  class AssociationMap\n    DATAMATRIX_KEY = 'part_data'\n\n    # Initializes an {AssociationMap} for the given item, operation, or plan.\n    #\n    # @param object [DataAssociator]  the object to which to associated data\n    def initialize(object)\n      @object = object\n      @map = {}\n\n      @object.associations.each do |datum|\n        @map[datum[0]] =\n          if @object.upload(datum[0]).nil?\n            datum[1]\n          else\n            UploadAssoc.new(datum[1], @object.upload(datum[0]))\n          end\n      end\n\n      if object.is_a? Collection\n        initialize_part_data\n        data_matrix_all(@object, @map[DATAMATRIX_KEY])\n      end\n    end\n\n    # Retrieves part_data from the data associations of constituent parts.\n    # achieves forward compatibility with AQ Part update\n    def data_matrix_all(coll, data_matrix)\n      pas = coll.part_associations\n      part_ids = pas.collect(\u0026:part_id)\n      das = DataAssociation.where(parent_class: 'Item', parent_id: part_ids)\n      pas.each do |pa|\n        data_matrix[pa.row][pa.column] = {}\n        das.select { |da| da.parent_id == pa.part_id }.each do |da|\n          data_matrix[pa.row][pa.column][da.key] = da.value\n        end\n      end\n      data_matrix\n    end\n\n    # All in one static method which associates a key and value\n    # to the associations hash of a given object. If an association already\n    # exists at the given key, it will be replaced. Can associate to parts of collection either\n    # using a part field value, or an optional coordinate specification with a collection\n    #\n    # @param object [DataAssociator]  the object to which data is to be associated. Can be an io field value\n    # @param key [String]  the key for the association\n    # @param data [serializable object]  the data for the association\n    # @param opts [Hash]  additional method options\n    # @option coord [tuple Array]  specify r, c index of the data matrix of the object to upload to,\n    #                   rather than directly to the object. Requires that object is a collection.\n    # @option data_matrix [String]  optionally, when associating to a part of a collection, use a\n    #                         data matrix besides the default one\n    def self.associate_data(object, key, data, opts = {})\n      defaults = { data_matrix: DATAMATRIX_KEY }\n      opts.merge defaults\n      raise 'Bad Arguments: cannot associate to a part and specify coords at the same time' if object.is_a?(FieldValue) \u0026\u0026 opts[:coord]\n      if object.is_a?(FieldValue)\n        assoc_map = AssociationMap.new(object.collection)\n        assoc_map.putrc(object.row, object.column, key, data)\n      elsif opts[:coord]\n        assoc_map = AssociationMap.new(object)\n        assoc_map.putrc(opts[:coord][0], opts[:coord][1], key, data)\n      elsif object.is_part\n        collection = Collection.find(object.containing_collection.id)\n        assoc_map = AssociationMap.new(collection)\n        row, column = collection.find(object).first\n        assoc_map.putrc(row, column, key, data)\n      else # Normal case that deals directly with object\n        assoc_map = AssociationMap.new(object)\n        assoc_map.put(key, data)\n      end\n      assoc_map.save\n    end\n\n    # All in one static method which gets an associated value\n    # from the associations hash of a given object. If an association doesn't\n    # exist at the given key, returns nil. Can get associations from parts of collection either\n    # using a part field value, or an optional coordinate specification with a collection\n    #\n    # @param object [DataAssociator]  the object to which data is to be associated, can be an io field value\n    # @param key [String]  the key for the association\n    # @param opts [Hash]  additional method options\n    # @option coord [tuple Array]  specify r, c index of the data matrix of the object to upload to,\n    #                   rather than directly to the object. Requires that object is a collection.\n    # @option data_matrix [String]  optionally, when retrieving association from a part of a collection,\n    #                         use a matrix besides the default one\n    # @return [serializable object]  the data stored in the associations of the given object at the given key\n    def self.get_associated_data(object, key, opts = {})\n      defaults = { data_matrix: DATAMATRIX_KEY }\n      opts.merge defaults\n      raise 'Bad Arguments: cannot get data from a part and specify coords at the same time' if object.is_a?(FieldValue) \u0026\u0026 opts[:coord]\n      if object.is_a?(FieldValue)\n        assoc_map = AssociationMap.new(object.collection)\n        return assoc_map.getrc(object.row, object.column, key)\n      elsif opts[:coord]\n        assoc_map = AssociationMap.new(object)\n        return assoc_map.getrc(opts[:coord][0], opts[:coord][1], key)\n      elsif object.is_part\n        collection = Collection.find(object.containing_collection.id)\n        assoc_map = AssociationMap.new(collection)\n        row, column = collection.find(object).first\n        return assoc_map.getrc(row, column, key)\n      else # Normal case that deals directly with object\n        assoc_map = AssociationMap.new(object)\n        return assoc_map.get(key)\n      end\n    end\n\n    # Adds an association for the data with the key.\n    # The data must be serializable.\n    #\n    # @param key [String]  the key for the association\n    # @param data [serializable object]  the data for the association\n    # @param opts [Hash]  Additional Options\n    # @option tag  [String]  If putting an Upload, optionally specify an extra label\n    def put(key, data, opts = { tag: {} })\n      @map[key] = if data.is_a?(Upload)\n                    UploadAssoc.new(opts[:tag], data)\n                  else\n                    data\n                  end\n    end\n\n    # Adds an association for the data with the key, for\n    # a specific row, column coordinate within a collection\n    # If the data_matrix for the collection has not been created yet, it is initialized\n    #\n    # @requires  current object is a Collection, and r,c corresponds to a valid location in the object\n    # @param r [Integer]  the row of the part within the collection to associate to\n    # @param c [Integer]  the column of the part within the collection to associate to\n    # @param key [String]  the key for the association\n    # @param data [serializable object]  the data for the association\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    def putrc(row, column, key, data, data_matrix = DATAMATRIX_KEY)\n      # if the data_matrix for this collection does not exist yet, initialize it.\n      initialize_part_data(data_matrix)\n      @map[data_matrix][row][column][key] = data\n    end\n\n    # To be called when the object of association is a collection,\n    # establishes a matrix parallel to the sample matrix which can\n    # be used to store additional information about individual parts\n    # Each slot in the matrix will be a new empty hash.\n    #\n    # @param coll [Collection]  the object for which part-data matrix will be initialized\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    def initialize_part_data(data_matrix = DATAMATRIX_KEY)\n      raise \"Invalid Method Call: cannot associate part data to an object that isn't a collection\" unless @object.is_a?(Collection)\n      # TODO: fix the following so that can use the Base method\n      # coll = collection_from(@object.id)\n      coll = Collection.find(@object.id)\n      @map[data_matrix] = Array.new(coll.dimensions[0]) { Array.new(coll.dimensions[1]) { {} } } if @map[data_matrix].nil?\n    end\n\n    # Returns the associated data for the key, if any.\n    #\n    # @param key [String]  the key for the association\n    # @returns the data object for the key, `nil` otherwise\n    def get(key)\n      data = @map[key]\n      if data.is_a?(UploadAssoc)\n        data.upload\n      else\n        data\n      end\n    end\n\n    # Gets an association for the data with the key, for\n    # a specific row, column coordinate within a collection\n    # Returns the associated data for the key, if any.\n    #\n    # @requires  current object is a Collection, and r,c corresponds to a valid location in the object\n    # @param r [Integer]  the row of the part within the collection to associate to\n    # @param c [Integer]  the column of the part within the collection to associate to\n    # @param key [String]  the key for the association\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    # @returns the data object for the key, `nil` otherwise\n    def getrc(row, column, key, data_matrix = DATAMATRIX_KEY)\n      @map[data_matrix][row][column][key] unless @map[data_matrix].nil?\n    end\n\n    # Retrieve the associations for all parts of the collection\n    # as a matrix.\n    # @requires  current object is a collection\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    # @returns  the data matrix, if one exists\n    def get_data_matrix(data_matrix = DATAMATRIX_KEY)\n      Matrix.rows(@map[data_matrix])\n    end\n\n    # Replace or initialize the data matrix for this object\n    # with a custom one.\n    # @requires  the current object is a collection\n    # `matrix` have the same row column dimensions as the collection\n    #\n    # @param new_matrix [Matrix]  the new data matrix\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix (by key) to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n\n    def set_data_matrix(matrix, data_matrix = DATAMATRIX_KEY)\n      @map[data_matrix] = matrix.to_a\n    end\n\n    # Saves the associations in this map to Aquarium.\n    def save\n      das = []\n      @map.each_key do |key|\n        if key == DATAMATRIX_KEY\n          das.concat save_data_matrix_alt(@object, @map[key])\n        elsif @map[key].is_a? UploadAssoc\n          # TODO: update this to lazy associate once aq is updated to hav lazy upload assoc (on master, just not on server yet)\n          @object.associate(key, @map[key].tag, @map[key].upload)\n        else\n          das \u003c\u003c @object.lazy_associate(key, @map[key])\n        end\n      end\n      DataAssociation.import(das, on_duplicate_key_update: [:object]) unless das.empty?\n      @object.save\n      nil\n    end\n\n    # saves part_data to the data associations of constituent parts.\n    # achieves forward compatibility with AQ Part update\n    # built off of set_data_matrix from collection.rb\n    def save_data_matrix_alt(coll, matrix, offset: [0, 0])\n      pm = coll.part_matrix\n      das = []\n\n      uniq_keys = matrix.flatten.map(\u0026:keys).flatten.uniq\n      dms_by_key = {}\n      uniq_keys.each do |key|\n        dms_by_key[key] = coll.data_matrix(key)\n      end\n\n      coll.each_row_col(matrix, offset: offset) do |x, y, ox, oy|\n        next unless !matrix[x][y].nil? \u0026\u0026 pm[ox][oy] # this part has das\n        matrix[x][y].each do |k, v|\n          if pm[ox][oy]\n            if dms_by_key[k][ox][oy]\n              da = dms_by_key[k][ox][oy]\n              da.object = { k =\u003e v }.to_json\n              das \u003c\u003c da\n            else\n              das \u003c\u003c pm[ox][oy].lazy_associate(k, v)\n            end\n          end\n        end\n      end\n\n      das\n    end\n\n    # Returns an array of all the keys in this map\n    def keys\n      @map.keys\n    end\n\n    # Returns the string representation of the map\n    def to_string\n      @map.to_s\n    end\n\n    alias to_s to_string\n  end\n\n  # private class that is used to deal with associating upload objects alongside their tag\n  class UploadAssoc\n    def initialize(tag, upload)\n      @upload = upload\n      @tag = tag || {}\n    end\n\n    def change_tag(new_tag)\n      @tag = new_tag\n    end\n\n    attr_reader :upload\n\n    attr_reader :tag\n  end\n\n  # Utilizes the part-data matrix of collections to store information about the history of\n  # parts of a collection. PartProvenance initializes and relies on two fields of every part-data\n  # slot: `source` and `destination`.\n  # `source` will store a list of item ids (with rc index if applicable),\n  # of all the ingredients used to make this part, and destination will use the same data format\n  # to record all of the places this part was used in.\n  # Item-Item provenance can technically be recorded as well with this library, but it will not\n  # be necessary.\n  #\n  module PartProvenance\n    SOURCE = 'source'\n    DESTINATION = 'destination'\n\n    # Record an entry to the provenance data between two parts, or a part and an item.\n    # This will populate the destination field of `from`, and the source field\n    # of the `to` in their respective associations. If from_coord or to_coord is specified, then\n    # the associations of the part of the from/to collection at that coordinate will\n    # populated instead.\n    #\n    # @param opts [Hash]  Arguments specifying which objects to record relation for\n    # @option from [Item/Collection]  the item or collection where sample transfer originated\n    # @option to [Item/Collection]  the item or collection for destination of sample transfer\n    # @option from_coord [Tuple Array]  optionally, specify the coordinate selecting a part of the collection, if `to` was a collection\n    # @option to_coord [Tuple Array]  optionally, specify the coordinate selecting a part of the collection, if `from` was a collection\n    # @option additional_relation_data [Hash]  optionally, add additional key/value pairs to add to both object's routing data\n    #                         for this relation. For example, you might want to specify the volume of the transfer,\n    #                         or which colony was picked from a plate\n    # @option from_map [AssociationMap]  existing AssociationMap for the given from-object, required to successfully associate provenance to\n    #                           the `from` item\n    # @option to_map [AssociationMap]  existing AssociationMap for the given to-object, required to successfully associate provenance to\n    #                           the `to` item\n    def add_provenance(opts = {})\n      if opts[:from] == opts[:to] # special case: provenance between two parts on the same collection\n        opts[:from_map] = opts[:to_map] # ensure from map and to map are the same object for this case\n      end\n\n      # creating information hashes to represent `from` and `to` relationship data\n      from_info = serialize_as_simple_tag(opts[:from], opts[:from_coord], opts[:additional_relation_data])\n      to_info = serialize_as_simple_tag(opts[:to], opts[:to_coord], opts[:additional_relation_data])\n\n      # in destination field of `from`, add information tag representing `to`\n      append_to_association(opts[:from_map], DESTINATION, to_info, coord: opts[:from_coord]) if opts[:from_map]\n\n      # in source field of `to`, add information tag representing `from`\n      append_to_association(opts[:to_map], SOURCE, from_info, coord: opts[:to_coord]) if opts[:to_map]\n    end\n\n    # Retrieves a list of sources that were used to construct the given part\n    # of a Collection\n    #\n    # @param object [FieldValue/Collection]  the part of interest, or the collection which\n    #                 contains the part of interest. For the second case, coord must also be specified\n    # @param coord [Tuple Array]  the r,c index of the target part\n    def sources(object, coord = nil)\n      if coord\n        AssociationMap.get_associated_data(object, SOURCE, coord: coord)\n      else\n        AssociationMap.get_associated_data(object, SOURCE)\n      end\n    end\n\n    # Retrieves a list of destinations that were made using the given part\n    # of a Collection\n    #\n    # @param object [FieldValue/Collection]  the part of interest, or the collection which\n    #                 contains the part of interest. For the second case, coord must also be specified\n    # @param coord [Tuple Array]  the r,c index of the target part\n    def destinations(object, coord = nil)\n      if coord\n        AssociationMap.get_associated_data(object, DESTINATION, coord: opts[:coord])\n      else\n        AssociationMap.get_associated_data(object, DESTINATION)\n      end\n    end\n\n    # For the given associatable target object, appends or concatenates the given datum_to_append to the association\n    # at `key` for that object\n    #\n    # @param association_map [AssocioationMap]  an AssociationMap that will have its associations appended to.\n    # @param key [String/Symbol]  The association key which maps to an appendable object\n    # @param datum_to_append [Serializable Object]  the element to append to the list at the value for the given key\n    # @param opts [Hash]  additional options\n    # @option coord [Tuple array]  coordinate of target part, if association target is a collection\n    def append_to_association(association_map, key, datum_to_append, opts = {})\n      if opts[:coord] # we will be interacting with the associations of a part of a collection if coord is specified\n        association_map.putrc(opts[:coord][0], opts[:coord][1], key, []) if association_map.getrc(opts[:coord][0], opts[:coord][1], key).nil?\n        association_map.getrc(opts[:coord][0], opts[:coord][1], key) \u003c\u003c  datum_to_append\n      else\n        association_map.put(key, []) if association_map.get(key).nil?\n        association_map.get(key) \u003c\u003c datum_to_append\n      end\n    end\n\n    # Given an item, or a part of a collection, serializes it into a simple tag which can be used to retrieve it.\n    #\n    # @param item [Item/FieldValue]  can be either an Item, or\n    #                         an i/o object corresponding to a part of a collection, which can be thought of\n    #                         as constituting a 'sub item'\n    def serialize_as_simple_tag(item, coord, additional_info)\n      info = if item.collection? \u0026\u0026 coord\n               { id: item.id, row: coord[0], column: coord[1] }\n             elsif (item.is_a? Item) || (item.is_a? Collection)\n               { id: item.id }\n             else\n               raise 'Argument is neither a part nor an item'\n             end\n      info.merge!(additional_info) unless additional_info.nil?\n      info\n    end\n  end\nend\n"}},{"library":{"name":"Centrifuge","category":"Standard Libs","code_source":"# abemill@uw.edu\r\n# This module is made to cover all common cases of directing the tech to\r\n# centrifuge, decant, and resuspend multiple batches of tubes.\r\n# centrifuge_resuspend_cycle is the public method of this module.\r\n# It allows staggered centrifuging so that the tech can be resuspending\r\n# the previous batch while the next batch is centrifuging.\r\nmodule Centrifuge\r\n  class Batch\r\n    attr_reader :marker, :tubes\r\n\r\n    def initialize(args)\r\n      @marker = args[:marker]\r\n      @tubes = args[:tubes]\r\n    end\r\n\r\n    # Partition the given tubes list into batches.\r\n    # Returns a list of Batch objects, each having a letter marker, and a list\r\n    # of tubes.\r\n    def self.initialize_batches(tubes, centrifuge_slots, protocol)\r\n      @@protocol = protocol # we need this to use show commands in Batch methods\r\n      @@batch_size = centrifuge_slots\r\n      tube_batches = tubes.each_slice(centrifuge_slots).to_a\r\n      batches = []\r\n      tube_batches.each_with_index do |tube_batch, i|\r\n        batch_id = [(i + 65).chr]\r\n        batches.push Batch.new(marker: batch_id, tubes: tube_batch)\r\n      end\r\n      batches\r\n    end\r\n    \r\n    def self.batch_size\r\n      @@batch_size\r\n    end\r\n\r\n    # returns a new list of batches produced by reducing the amount of tubes in\r\n    # each batch and then combining batches, Batches.size will be halved.\r\n    def self.combine_batches(batches)\r\n      paired_batches = batches.each_slice(2).to_a\r\n      batches = []\r\n      paired_batches.each do |pair|\r\n        pair.each_with_index do |batch, i|\r\n          pair[i] = batch.combine_tubes\r\n        end\r\n        batches.push(pair[0].combine_with(pair[1]))\r\n      end\r\n      batches\r\n    end\r\n\r\n    # Instructs tech to reduce the number of tubes in the given batch by a power\r\n    # of 2, combining tubes of the same sample. This only shows the instructions\r\n    # and does not alter the state of batches[].\r\n    # (that happens in combine_batches)\r\n    def combine_tubes_instructions()\r\n      batch = self\r\n      @@protocol.show do\r\n        title 'Combine Tubes'\r\n        if batch.marker.length == 1\r\n          note 'Reduce the number of tubes in '\\\r\n               \"\u003cb\u003ebatch #{batch.marker.to_sentence}\u003c/b\u003e from #{batch.tubes.length} \"\\\r\n               \"to #{batch.tubes.length / 2} by combining tubes.\"\r\n        else\r\n          note \"Together, \u003cb\u003ebatches #{batch.marker.to_sentence}\u003c/b\u003e have a \"\\\r\n               \"total of #{batch.tubes.length} tubes. Reduce the sum of tubes to \"\\\r\n               \"#{batch.tubes.length / 2} by combining tubes from \"\\\r\n               \"#{batch.marker.length == 2 ? 'both' : 'all'} batches.\"\r\n        end\r\n        note 'Combine tubes by carefully pouring one tube into tube '\\\r\n             'that shares the same id.'\r\n        note 'All tubes after combination should have the same volume. '\\\r\n             'Do not \"double combine\" any tubes.'\r\n        batch.tubes.uniq.each do |tube|\r\n          note \"Combine each tube labeled \u003cb\u003e#{tube}\u003c/b\u003e \"\\\r\n               \"with another tube labeled \u003cb\u003e#{tube}\u003c/b\u003e.\"\r\n        end\r\n        if Cycle.cold?\r\n          warning 'Once finished with combining, '\\\r\n                  'immediately place tubes in ice bath.'\r\n        end\r\n      end\r\n    end\r\n\r\n    # instructions to place tubes from batch into the centrifuge\r\n    def centrifuge(centrifuge_instructions)\r\n      rpm = centrifuge_instructions[:rpm]\r\n      time = centrifuge_instructions[:time]\r\n      temp = centrifuge_instructions[:temp]\r\n      batch = self\r\n      @@protocol.show do\r\n        title 'centrifuge tubes'\r\n        note \"Set the centrifuge to #{rpm} rpm for #{time} minutes at \"\\\r\n             \"#{temp} C. Ensure correct centrifuge tube holders are in place.\"\r\n        note \"Move all tubes from \u003cb\u003e#{'batch'.pluralize(batch.marker.length)} \"\\\r\n             \"#{batch.marker.to_sentence}\u003c/b\u003e to centrifuge and press start.\"\r\n        if batch.tubes.length.odd?\r\n          warning 'Balance the centrifuge with a dummy tube that is filled '\\\r\n                  'with the same volume of liquid as the other tubes.'\r\n        end\r\n      end\r\n    end\r\n\r\n    # instructions to remove tubes from the centrifuge\r\n    # after it has finished a spin\r\n    def remove_tubes()\r\n      batch = self\r\n      @@protocol.show do\r\n        title 'Remove Tubes from Centrifuge'\r\n        note 'Wait for centrifuge to finish'\r\n        note 'Once the centrifuge has finished its spin, '\\\r\n             'remove tubes from centrifuge.'\r\n        note \"The removed tubes should be marked as \"\\\r\n             \"\u003cb\u003e#{'batch'.pluralize(batch.marker.length)} \"\\\r\n             \"#{batch.marker.to_sentence}\u003c/b\u003e.\"\r\n        if Cycle.cold?\r\n          warning 'Once removed from centrifuge, '\\\r\n                'immediately place tubes in ice bath.'\r\n        end\r\n      end\r\n    end\r\n\r\n    # instructions to resuspend tubes\r\n    def resuspend(resuspend_instructions)\r\n      volume = resuspend_instructions[:volume]\r\n      media = resuspend_instructions[:media]\r\n\r\n      decant()\r\n\r\n      batch = self\r\n      @@protocol.show do\r\n        title \"Resuspend cells in #{volume}mL of #{media}\"\r\n        note \"Grab bottle of #{media} from fridge.\"\r\n        note \"Carefully pour #{volume}mL of #{media} into each tube from \u003cb\u003e\"\\\r\n             \"#{'batch'.pluralize(batch.marker.length)} #{batch.marker.to_sentence}\u003c/b\u003e.\"\r\n        note 'Shake and vortex tubes until pellet is completely resuspended.'\r\n        warning 'When not actively shaking or vortexing keep tubes in ice, '\\\r\n                'and place all tubes in ice once resuspended.' if Cycle.cold?\r\n        note \"At next opportunity, bring #{media} back to fridge, \"\\\r\n             'or to dishwasher if empty.'\r\n      end\r\n    end\r\n\r\n    def decant()\r\n      batch = self\r\n      @@protocol.show do\r\n        title 'Decant tubes'\r\n        note \"Take #{Cycle.cold? ? 'ice bucket' : 'tubes'} to the \"\\\r\n             \"dishwasing station, and pour out supernatant of tubes from \u003cb\u003e\"\\\r\n             \"#{'batch'.pluralize(batch.marker.length)} #{batch.marker.to_sentence}\u003c/b\u003e.\"\r\n        note 'Place tubes in ice immediately after decanting.' if Cycle.cold?\r\n      end\r\n    end\r\n\r\n    # returns new batch which is the combination of this batch\r\n    # and the other batch\r\n    # helper for combine_batches\r\n    def combine_with(other)\r\n      if other\r\n        new_marker = marker.concat other.marker\r\n        new_tubes = tubes.concat other.tubes\r\n        return Batch.new(marker: new_marker, tubes: new_tubes)\r\n      else\r\n        return self\r\n      end\r\n    end\r\n\r\n    # returns a new batch with a half the tubes, where like tubes have been\r\n    # combined.\r\n    # helper for combine_batches\r\n    def combine_tubes\r\n      new_tubes = []\r\n      new_tubes.concat(tubes)\r\n      batch = Batch.new(marker: marker,tubes: [])\r\n      tubes.uniq.each do |short_id|\r\n        sameids = new_tubes.select { |tube| tube == short_id }\r\n        batch.tubes.concat(sameids[0, sameids.length / 2])\r\n      end\r\n      batch\r\n    end\r\n  end\r\n\r\n  class Cycle\r\n    attr_reader :centrifuge_instructions, :resuspend_instructions\r\n    def initialize(cycle_instructions)\r\n      @centrifuge_instructions = { temp: cycle_instructions[:cent_temp],\r\n                                   rpm: cycle_instructions[:cent_rpm],\r\n                                   time: cycle_instructions[:cent_time] }\r\n\r\n      @resuspend_instructions = { media: cycle_instructions[:sus_media],\r\n                                  volume: cycle_instructions[:sus_volume] }\r\n\r\n      @combine = cycle_instructions[:combine]\r\n    end\r\n\r\n    def self.initialize_cycles(cycles_data, cold)\r\n      @@cold = cold\r\n      cycles = cycles_data.map do |cycle_data|\r\n        Cycle.new(cycle_data)\r\n      end\r\n      cycles\r\n    end\r\n\r\n    def self.cold?\r\n      @@cold\r\n    end\r\n\r\n    def combine?\r\n      @combine\r\n    end\r\n  end\r\n\r\n  ##\r\n  # @param [Hash] opts  The parameters which indicate cycling behaivor\r\n  # @option [Array\u003cItem\u003e] items  The array of items for which each will\r\n  #           be split into smaller tubes and then centrifuge cycled on.\r\n  # @option [Float] start_vol  Volume of liquid that each item begins with.\r\n  # @option [Float] tube_vol  Volume of centrifuge tubes that\r\n  #           start_vol will be divided amongst\r\n  # @option [Integer] centrifuge_slots  Number of slots in the centrifuge.\r\n  #           Must be an even number.\r\n  # @option [Array\u003cHash\u003e] cycles  Instructions for each cycle of centrifuging.\r\n  #           Cycles.length indicates how many centrifuge/wash cycles.\r\n  #           Elements of cycles contain instructions for the centrifuging\r\n  #           and resuspension settings for that cycle.\r\n  # @option [Boolean] :cold  Indicate if centrifuge cycling is done on ice.\r\n  #           Default: no\r\n  # @option [Symbol] :cb_extra_instructions  Extra instructions for tech\r\n  #           while waiting for final centrifuge batch to finish,\r\n  #           for example, tidying up workspace. Default: none\r\n  # @effects  This method Instructs tech to do cycles of centrifuging,\r\n  #           decanting, and resuspending on each item\r\n  #           as per the instructions stored in cycles.\r\n  def centrifuge_resuspend_cycle(opts = {})\r\n    # Bench setup is required before we begin centrifuging\r\n    # During setup, the items will be aliquoted into tubes,\r\n    # and each aliquoted tube will be marked with a short id.\r\n    # This maps tubes to the item they originated from, and will\r\n    # keep track of which tubes contain the same substance.\r\n    # the index of the parent item in the items[] is used\r\n    # for the short id.\r\n    # Also, tubes are grouped into batches that will fit in centrifuge,\r\n    # and marked with a capital letter batch identifier, in addition to their\r\n    # short id that indicates their ancestry.\r\n\r\n    # computation\r\n    tubes = initialize_tubes(opts)\r\n    batches = Batch.initialize_batches(tubes, opts[:centrifuge_slots], self)\r\n    cycles = Cycle.initialize_cycles(opts[:cycles], opts[:cold])\r\n\r\n    # tech instructions\r\n    setup_steps(cycles, batches,\r\n              opts[:start_vol], opts[:tube_vol], opts[:items])\r\n\r\n    # Loop through each cycle of centrifuging and resuspending found in cycles[]\r\n    # and perform that cycle on each batch of tubes in found in batches[]\r\n    this_batch = nil\r\n    cycles.each_with_index do |cycle, i|\r\n      prev_cycle = cycles[i - 1]\r\n      \r\n      # Reconfigure batches array to be shortened by combing batches\r\n      # so each batch has enough tubes to fill centrifuge.\r\n      batches = Batch.combine_batches(batches) if prev_cycle.combine?\r\n\r\n      batch_iterator = batches.each\r\n      first_batch = batch_iterator.next\r\n      if i.zero?\r\n        # first batch of first cycle, the centrifuge is empty\r\n        first_batch.centrifuge(cycle.centrifuge_instructions)\r\n      else\r\n        this_batch.remove_tubes\r\n        if batches.length == 1\r\n          # this_batch == first_batch || first_batch contains this_batch\r\n          this_batch.resuspend(prev_cycle.resuspend_instructions)\r\n          this_batch.combine_tubes_instructions if prev_cycle.combine?\r\n          first_batch.centrifuge(cycle.centrifuge_instructions)\r\n        else\r\n          # first_batch and this_batch are not associated,\r\n          # we can start centrifuging first_batch before we resuspend this_batch\r\n          first_batch.centrifuge(cycle.centrifuge_instructions)\r\n          this_batch.resuspend(prev_cycle.resuspend_instructions)\r\n          this_batch.combine_tubes_instructions if prev_cycle.combine?\r\n        end\r\n      end\r\n\r\n      this_batch = first_batch\r\n      while has_next? batch_iterator\r\n        next_batch = batch_iterator.next\r\n        this_batch.remove_tubes\r\n        next_batch.centrifuge(cycle.centrifuge_instructions)\r\n        this_batch.resuspend(cycle.resuspend_instructions)\r\n        this_batch.combine_tubes_instructions if cycle.combine?\r\n        this_batch = next_batch\r\n      end\r\n    end\r\n\r\n    # Show any extra steps specified by client to do\r\n    # while waiting for last spin to finish.\r\n    extra_instructions(opts[:cb_extra_instructions])\r\n\r\n    final_cycle = cycles.last\r\n    this_batch.remove_tubes\r\n    this_batch.resuspend(final_cycle.resuspend_instructions)\r\n    if final_cycle.combine?\r\n      this_batch.combine_tubes_instructions\r\n      batches = Batch.combine_batches(batches)\r\n    end\r\n\r\n    # On remaining tubes,\r\n    # replaces the short id with the id of original parent item.\r\n    relabel_tubes(batches, opts[:items])\r\n  end\r\n\r\n  private\r\n\r\n  # Ensures state of variables is acceptable\r\n  # TODO add more checks\r\n  def error_checks(cycles, batches, opts)\r\n    raise 'odd slot centrifuge not supported' if Batch.batch_size.odd?\r\n    raise 'wrong cycle amount' if cycles.length != opts[:cycles].length\r\n    raise 'wrong batch size' if Batch.batch_size != opts[:centrifuge_slots]\r\n  end\r\n\r\n  # Initializes array of integers that represent tubes\r\n  # identified by their short_id which corresponds to the parent item.\r\n  # Also returns\r\n  def initialize_tubes(opts)\r\n    combination_occurs = opts[:cycles].any? { |cycle| cycle[:combine] == true }\r\n    tubes_per_item = (opts[:start_vol] / opts[:tube_vol]).floor\r\n    tubes_per_item += 1 if tubes_per_item.odd? \u0026\u0026 combination_occurs\r\n    tubes = []\r\n    opts[:items].each_with_index do |_item, i|\r\n      tubes_per_item.times do\r\n        tubes.push (i + 1)\r\n      end\r\n    end\r\n    tubes\r\n  end\r\n\r\n  # Gives the tech instructions to prepare for centrifuging.\r\n  def setup_steps(cycles, batches, start_vol, tube_vol, items)\r\n    tubes = batches.map { |batch| batch.tubes }.flatten\r\n\r\n    fetch_supplies(cycles, tubes.length, tube_vol)\r\n    if Cycle.cold?\r\n      prepare_ice_bath\r\n      chill_tubes(tubes.length, tube_vol)\r\n    end\r\n    aliquot_items_to_tubes(items, tubes, start_vol, tube_vol)\r\n    batch_tubes_instructions(batches)\r\n  end\r\n\r\n  # Instructs tech to fetch all the media and tubes that will be required.\r\n  def fetch_supplies(cycles, num_tubes, tube_vol)\r\n    media_to_volume = calculate_media_volumes(cycles, num_tubes)\r\n\r\n    media_location = 'on bench'\r\n    tube_location = 'on bench'\r\n    if Cycle.cold?\r\n      media_location = 'in fridge'\r\n      tube_location = 'in freezer'\r\n    end\r\n\r\n    show do\r\n      title 'Grab required suspension media'\r\n      note 'For the following set of centrifuging instructions, you will need'\\\r\n           ' the following supplies: '\r\n      media_to_volume.each do |media, volume|\r\n        check \"At least #{volume}mL of #{media}\"\r\n      end\r\n      note \"Place all media bottles #{media_location}\"\\\r\n           ' in preparation for centrifuge.'\r\n      note \"Place #{num_tubes} #{tube_vol}mL tubes #{tube_location}\"\\\r\n           ' in preparation for centrifuge.'\r\n    end\r\n  end\r\n\r\n  def calculate_media_volumes(cycles, num_tubes)\r\n    media_to_volume = Hash.new\r\n    media_list = cycles.map do |cycle|\r\n      cycle.resuspend_instructions[:media]\r\n    end.uniq\r\n\r\n    media_list.each do |media|\r\n      volumes = cycles.select { |cycle|\r\n        cycle.resuspend_instructions[:media] == media\r\n      }.map { |cycle|\r\n        cycle.resuspend_instructions[:volume]\r\n      }\r\n      total_volume = volumes.sum * num_tubes\r\n      media_to_volume[media] = total_volume\r\n    end\r\n    media_to_volume\r\n  end\r\n\r\n  # Instructs tech to make an ice bath and immerse empty tubes in it.\r\n  def prepare_ice_bath\r\n    show do\r\n      title 'Go to Bagley to get ice (Skip if you already have ice)'\r\n      note 'Walk to ice machine room on the second floor in Bagley with a '\\\r\n           'large red bucket, fill the bucket  full with ice.'\r\n      note 'If unable to go to Bagley, use ice cubes to make a water bath (of '\\\r\n           'mostly ice) or use the chilled aluminum bead bucket. (if using '\\\r\n           'aluminum bead bucket place it back in freezer between spins)'\r\n    end\r\n  end\r\n\r\n  def chill_tubes(num_tubes, tube_vol)\r\n    show do\r\n      title 'Prepare chilled tubes'\r\n      note \"Take the #{num_tubes} #{tube_vol}mL \"\\\r\n            \"#{'tube'.pluralize(num_tubes)} from the freezer \"\\\r\n            'and immerse in ice bath.'\r\n    end\r\n  end\r\n\r\n  # Instructs the tech to divide the volume of each item in items[] into\r\n  # equivolume aliquots for centrifuging.\r\n  def aliquot_items_to_tubes(items, tubes, start_vol, tube_vol)\r\n    tubes_per_item = tubes.length / items.length\r\n    aliquot_amount = [start_vol / tubes_per_item, tube_vol].min\r\n\r\n    show do\r\n      title \"Aliquot items into #{tube_vol}mL tubes for centrifuging\"\r\n      note 'You should have '\\\r\n           \"#{items.length * tubes_per_item} #{tube_vol}mL tubes.\"\r\n      if Cycle.cold?\r\n        note 'While labeling and pouring, '\\\r\n             'leave tubes in ice bath as much as possible.'\r\n      end\r\n      items.each_with_index do |item, i|\r\n        note \"Label #{tubes_per_item} tubes with short id: \u003cb\u003e#{i + 1}\u003c/b\u003e\"\r\n        note \"Carefully pour #{aliquot_amount}mL from #{item} \"\\\r\n             \"into each tube labeled as \u003cb\u003e#{i + 1}\u003c/b\u003e.\"\r\n      end\r\n      \r\n      if Cycle.cold?\r\n        note 'Leave tubes to chill for for 30 minutes.'\r\n        timer initial: { hours: 0, minutes: 30, seconds: 0}\r\n      end\r\n    end\r\n  end\r\n  \r\n  # Instructs the tech to group tubes into batches\r\n  # that will fit into the centrifuge\r\n  def batch_tubes_instructions(batches)\r\n    show do\r\n      title \"separate tubes into batches of #{Batch.batch_size} or less\"\r\n      note 'Group tubes into batches as shown and mark each tube '\\\r\n           'with its alphabetic batch identifier.'\r\n      batches.each do |batch|\r\n        check \"\u003cb\u003e#{batch.tubes.to_sentence}\u003c/b\u003e: \"\\\r\n              \"batch \u003cb\u003e#{batch.marker}\u003c/b\u003e\"\r\n      end\r\n    end\r\n  end\r\n  \r\n  # Callback which runs client specified method during the time when\r\n  # the tech is waiting for the last batch of tubes to finish centrifuging.\r\n  def extra_instructions(method_name)\r\n    method(method_name.to_sym).call if method_name \u0026\u0026 (method_name != '')\r\n  end\r\n\r\n  # After centrifuging finishes, instruct tech to relabel the resulting tubes\r\n  # with the id of the item that they originated from, for convienence.\r\n  def relabel_tubes(batches, items)\r\n    result_tubes = batches.map { |batch| batch.tubes }.flatten\r\n    show do\r\n      title 'Label Finished Tubes'\r\n      note 'Tubes with the following ids remain: '\\\r\n           \"\u003cb\u003e#{result_tubes.to_sentence}\u003c/b\u003e.\"\r\n      note 'Label each tube with the item id '\\\r\n           'of the item that they originated from.'\r\n      items.each_with_index do |item, i|\r\n        note \"The tube(s) labeled as \u003cb\u003e#{i + 1}\u003c/b\u003e \"\\\r\n             \"should be relabeled as \u003cb\u003e#{item.id}\u003c/b\u003e.\"\r\n      end\r\n    end\r\n  end\r\n\r\n  # Helper method that allows manual iteration like in java\r\n  # when used alongside enumerator.next()\r\n  def has_next?(enum)\r\n    enum.peek\r\n    return true\r\n  rescue StopIteration\r\n    return false\r\n  end\r\nend\r\n"}},{"library":{"name":"CommonInputOutputNames","category":"Standard Libs","code_source":"module CommonInputOutputNames\n\n    INPUT_YEAST = 'Yeast Culture'\n    OUTPUT_YEAST = 'Yeast Culture'\n    MEDIA = 'Media'\n    DNA = 'DNA'\n    \n    INPUT_SAMPLE = 'Input Sample'\n    OUTPUT_SAMPLE = 'Output Sample'\n\n    INPUT_ARRAY = \"Input Array\"\n    OUTPUT_ARRAY = \"Output Array\"\n\n    FORWARD_PRIMER = 'Forward Primer'\n    REVERSE_PRIMER = 'Reverse Primer'\n    TEMPLATE = 'Template'\n    FRAGMENT = 'Fragment'\n    PROGRAM = 'Program'\n    PRIMER_PLATE = '96-Well Primer Aliquot Plate'\n\nend"}},{"library":{"name":"Debug","category":"Standard Libs","code_source":"module Debug\n  def print_object obj\n    if [Numeric, String].any? { |c| obj.is_a? c }\n      obj\n    elsif [Array].any? { |c| obj.is_a? c }\n      obj.map { |item| print_object item }\n    elsif [Hash].any? { |c| obj.is_a? c }\n      Hash[obj.map { |k, v| [k, print_object(v)] }]\n    else\n      s = obj ? obj.id.to_s : \"\"\n      s += \" #{obj.name}\" if obj.class.method_defined? :name\n      s\n    end\n  end\n\n  def log_info *args\n    if debug\n      show do\n        title \"Debug slide (#{args.length} #{\"arg\".pluralize args.length})\"\n\n        args.each do |arg|\n          note \"#{arg.class}: #{print_object arg}\"\n        end\n      end\n    end\n  end\n\n    def inspect(object, ident=nil)\n        show do\n            title \"\u003cspan style=\\\"background-color:yellow\\\"\u003eINSPECTING #{ident} (#{object.class})\u003c/span\u003e\"\n            if object.kind_of?(Array)\n              table object\n            else\n              note object.to_json\n            end\n        end\n    end\nend\n"}},{"library":{"name":"Feedback","category":"Standard Libs","code_source":"module Feedback\n  CONTAINER_NAME = \"Feedback (Virtual)\"\n  SAMPLE_TYPE_NAME = \"Operation Feedback\"\n  \n  # This method will prompt the technician to write feedback for the operations\n  # that they complete on each job. This feedback will be associated to an item\n  # that represents each operation type.\n  def get_protocol_feedback\n    \n    # Gets feedback from the user\n    if debug\n      feedback = \"testing for job id\"\n    else\n      feedback = ask_for_feedback\n    end\n    \n    if(!feedback.blank?)\n      associate_feedback feedback\n    end\n    \n    if debug\n      print_association\n    end\n    \n  end\n  \n  # Associates the feedback entered by the lab technician to the OperationType of the protocol\n  # that uses this library.\n  #\n  # @param [String] the feedback entered by the lab technician.\n  def associate_feedback feedback\n    operation = OperationType.find(operation_type.id)\n    feedback = feedback + \"- job #{jid}\"\n  \n    feedback_array = []\n    if(!operation.get(:feedback).nil?)\n      feedback_array = operation.get(:feedback)\n    end\n    feedback_array.push(feedback)\n    operation.associate :feedback, feedback_array\n  end\n  \n  # Debugging method that prints all associations\n  def print_association\n    operation = OperationType.find(operation_type.id)\n    feedback_array = operation.get(:feedback)\n    if feedback_array\n      show do\n        title \"This is printing because debug is on\"\n        note \"#{feedback_array}\"\n      end\n    end\n  end\n  \n  # Returns the feedback entered by a lab technician.\n  #\n  # @return [Hash] the information returned by the feedback show block\n  def ask_for_feedback\n    feedback = show do\n      title \"We want your feedback\"\n      \n      note \"Notice anything weird with this protocol? Tell us below!\"\n      \n      get \"text\", var: \"feedback_user\", label: \"Enter your feedback here\", default: \"\"\n    end\n    feedback[:feedback_user] # return\n  end\n\nend"}},{"library":{"name":"InputOutput","category":"Standard Libs","code_source":"module InputOutput\n  def add_static_inputs ops, name, sample_name, container_name\n    ops.each do |op|\n      sample = Sample.find_by_name(sample_name)\n      container = ObjectType.find_by_name(container_name)\n      op.add_input name, sample, container\n      op.input(name).set item: sample.in(container.name).first\n    end\n  end\n  \n  def get_inputs_checked input_name\n    show do\n      title \"Gather the following item(s)\"\n       \n      operations.each do |op|\n        check \"#{op.input(input_name).item.id}: #{op.input(input_name).sample.name} at \u003cb\u003e#{op.input(input_name).item.location}\u003c/b\u003e\"\n      end\n    end\n  end\nend"}},{"library":{"name":"ItemActions","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\n# Assists with basic actions of items (eg trashing, moving, etc)\n\nmodule ItemActions\n  # Store all items used in input operations\n  # Assumes all inputs are non nil\n  #\n  # @param operations [OperationList] the list of operations\n  # @param location [String] the storage location\n  # @param type [String] the type of items to be stored('item', 'collection')\n  def store_inputs(operations, location: nil, type: nil)\n    store_io(operations, role: 'input', location: location, type: type)\n  end\n\n  # Stores all items used in output operations\n  # Assumes all outputs are non nil\n  #\n  # @param operations [OperationList] the operation list where all\n  #     output collections should be stored\n  # @param location [String] the storage location\n  # @param type [String] the type of items to be stored ('item', 'collection')\n  def store_outputs(operations, location: nil, type: nil)\n    store_io(operations, role: 'output', location: location, type: type)\n  end\n\n  # Stores all items of a certain role in the operations list\n  # Creates instructions to store items as well\n  #\n  # @param operations [OperationList] list of Operations\n  # @param role [String] whether material to be stored is an input or an output\n  # @param location [String] the location to store the material\n  # @param all_items [Boolean] an option to store all items not just collections\n  # @param type [String] the type of items to be stored ('item', 'collection')\n  def store_io(operations, role: 'all', location: nil, type: nil)\n    items = Set[]; role.downcase!; type.downcase!\n    operations.each do |op|\n      field_values = if role == 'input'\n                       yield op.inputs\n                     elsif role == 'output'\n                       yield op.outputs\n                     else\n                       yield (op.outputs + op.inputs)\n                     end\n\n      unless type.nil?\n        if type == 'collection'\n          field_values.reject! { |fv| fv.object_type.handler == 'collection' }\n        elsif type == 'item'\n          field_values.select! { |fv| fv.object_type.handler == 'collection' }\n        end\n      end\n\n      items.concat(field_values.map(\u0026:item))\n    end\n    store_items(items, location: location)\n  end\n\n  # Instructions to store a specific item\n  # TODO have them move the items first then move location in AQ\n  #\n  # @param items [Array\u003citems\u003e] the things to be stored\n  # @param location [String] Sets the location of the items if included\n  def store_items(items, location: nil)\n    set_locations(items, location) unless location.nil?\n    tab = create_location_table(items)\n    show do\n      title 'Put Away the Following Items'\n      table tab\n    end\n  end\n\n  # Sets the location of all objects in array to some given locations\n  #\n  # @param items Array[Collection] or Array[Items] an array of any objects\n  # that extend class Item\n  # @param location [String] the location to move object to\n  # (String or Wizard if Wizard exists)\n  def set_locations(items, location)\n    items.each do |item|\n      item.move_to(location)\n      item.save\n    end\n  end\n\n  # Directions to layout materials for easy use\n  #\n  # @materials [Array\u003citems\u003e]\n  def layout_materials(materials)\n    show do\n      title 'Layout Materials'\n      note 'Please set out the following items for easy access'\n      table create_location_table(materials)\n    end\n  end\n\n  # Directions to retrieve materials\n  #\n  # @materials [Array\u003citems\u003e]\n  def retrieve_materials(materials)\n    show do\n      title 'Retrieve Materials'\n      note 'Please get the following items'\n      table create_location_table(materials)\n    end\n  end\n\n  # Creates table directing technician on where to store materials\n  #\n  # @param collection [Collection] the materials that are to be put away\n  # @return location_table [Array\u003cArray\u003e] of Collections and their locations\n  def create_location_table(items)\n    location_table = [['ID', 'Object Type', 'Location']]\n    items.each do |item|\n      location_table.push([item.id, item.object_type.name, item.location])\n    end\n    location_table\n  end\n\n  # Gives directions to throw away objects (collection or item)\n  #\n  # @param items [Array\u003citems\u003e] Items to be trashed\n  # @param hazardous [boolean] if hazardous then true\n  def trash_object(items, waste_container: 'Biohazard Waste')\n    set_locations(items, location: waste_container)\n    tab = create_location_table(items)\n    show do\n      title 'Properly Dispose of the following items:'\n      table tab\n    end\n    items.each { |item| item.mark_as_deleted }\n  end\nend\n"}},{"library":{"name":"LabwareNames","category":"Standard Libs","code_source":"needs \"Standard Libs/Units\"\n\nmodule LabwareNames\n    include Units\n    \n    # Tubes\n    TUBE_50_ML_CONICAL = \"50 #{MILLILITERS} conical tube\"\n    TUBE_15_ML_CONICAL = \"15 #{MILLILITERS} conical tube\"\n    TUBE_MICROFUGE = \"1.5 #{MILLILITERS} microcentrifuge tube\"\n    TUBE_MICROCENTRIFUGE = TUBE_MICROFUGE\n    \n    # Plates\n    PCR_PLATE = \"0.2 #{MILLILITERS} PCR plate\"\n    \n    # Misc\n    \"96-well -20#{DEGREES_C} cold blocks\"\nend"}},{"library":{"name":"MatrixTools","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\nneeds 'Standard Libs/Units'\nneeds 'Standard Libs/CommonInputOutputNames'\n\n# Contains methods for assembling and dispensing master mixes\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nmodule MasterMixHelper\n  include CommonInputOutputNames\n  include Units\n\n  # TODO: Get this out of here.\n  TEST = 'TEST'\n\n  # Group operations by multiple inputs\n  # @todo Make the grouped Operations be OperationLists\n  #\n  # @param input_names [Array\u003cString\u003e] names of inputs to be included\n  #   in grouping\n  # @param ops [OperationList, Array\u003cOperation\u003e] operations to be grouped\n  # @return [Array(Array\u003cString\u003e, Hash{Array\u003cFixNum\u003e =\u003e Array\u003cOperation\u003e})]\n  #   the input IDs with singletons eliminated, followed by\n  #   the grouped operations\n  def group_ops_by_inputs(input_names:, ops:)\n    input_names = eliminate_singletons(input_names: input_names, ops: ops)\n    grouped_ops = ops.group_by do |op|\n      input_item_id_array(input_names: input_names, op: op)\n    end\n    [input_names, grouped_ops]\n  end\n\n  # Remove input names from the list where each operation is a\n  #   different input item\n  #\n  # @param input_names [Array\u003cString\u003e] input names to be tested and,\n  #   if appropriate, eliminated\n  # @param ops [OperationList, Array\u003cOperation\u003e] operations\n  # @return [Array\u003cString\u003e] the input names with singletons eliminated\n  def eliminate_singletons(input_names:, ops:)\n    input_names.reject { |n| singletons?(input_name: n, ops: ops) }\n  end\n\n  # Tests whether each operation has a different item for a given input name and\n  #   returns true if each is different\n  #\n  # @param input_name [String] input name to be tested\n  # @param ops [OperationList, Array\u003cOperation\u003e] operations\n  # @return [Boolean]\n  def singletons?(input_name:, ops:)\n    ids = ops.map { |op| item_id(input_name: input_name, op: op) }\n    ids.uniq.length == ops.length\n  end\n\n  # Gets the ID for the Item or Part specified by a given input name\n  #\n  # @param input_name [String] input name to be tested\n  # @param op [Operation]\n  # @return [FixNum] the Item or Part ID\n  def item_id(input_name:, op:)\n    fv = op.input(input_name)\n    fv.part.try(:id) || fv.item.id\n  end\n\n  # Maps Item IDs for a given list of input names and a given operation\n  #\n  # @param input_names [Array\u003cString\u003e] input names to be mapped\n  # @param op [Operation]\n  # @return [Array\u003cFixNum\u003e]\n  def input_item_id_array(input_names:, op:)\n    input_names.map { |n| op.input(n).child_item_id }\n  end\n\n  # Makes master mix(es) for a set of operations\n  # Assumes that all operations have the same PCR program\n  #\n  # @param grouped_ops [Hash{Array\u003cFixNum\u003e =\u003e Array\u003cOperation\u003e}] hash of\n  #   operations grouped by input IDs\n  # @param input_names [Array\u003cString\u003e] input names corresponding to\n  #   grouped_ops keys\n  # @param composition [PCRComposition]\n  # @param mult [Float] Amount to multiply each component volume by\n  #   to account for pipetting error\n  # @return [Hash{String =\u003e Array\u003cOperation\u003e}] hash of operations grouped by\n  #   tube labels\n  def make_master_mixes(grouped_ops:, input_names:, composition:, mult: 1.0)\n    ops_by_master_mix = {}\n\n    grouped_ops.each_with_index do |(inputs, ops), i|\n      mm_tube_label = \"MM#{i + 1}\"\n      this_mult = mult * ops.length\n\n      master_mix_table = master_mix_table(\n        inputs: inputs,\n        input_names: input_names,\n        composition: composition,\n        mult: this_mult\n      )\n\n      show do\n        title \"Make Master Mix #{mm_tube_label}\"\n\n        check \"Get a 1.5mL tube and label it \u003cb\u003e#{mm_tube_label}\u003c/b\u003e.\"\n        note 'Add reaction components as indicated:'\n        table master_mix_table\n      end\n\n      ops_by_master_mix[mm_tube_label] = ops\n    end\n\n    show do\n      title 'Vortex and Spin Down'\n\n      check 'Vortex the master mix tubes briefly and spin down'\n    end\n\n    ops_by_master_mix\n  end\n\n  # Build table for volumes of master mix components\n  #\n  # @param inputs [Array\u003cFixNum\u003e] input item IDs\n  # @param input_names [Array\u003cString\u003e] input names\n  # @param composition [PCRComposition]\n  # @param mult [Float] Amount to multiply each component volume by to\n  #   account for pipetting error\n  # @return [Array\u003cArray\u003e] a 2D array formatted for the `table` method in Krill\n  def master_mix_table(inputs:, input_names:, composition:, mult:)\n    header = [\n      \"#{composition.polymerase.display_name} #{composition.polymerase.item}\",\n      \"#{composition.dye.display_name} #{composition.dye.item}\",\n      composition.water.display_name\n    ]\n\n    row = [\n      composition.polymerase.add_in_table(mult),\n      composition.dye.add_in_table(mult),\n      composition.water.add_in_table(mult)\n    ]\n\n    input_names.each_with_index do |input_name, i|\n      header \u003c\u003c \"#{input_name} #{inputs[i]}\"\n      row \u003c\u003c composition.input(input_name).add_in_table(mult)\n    end\n\n    [header, row].transpose\n  end\n\n  # Dispenses master mixes for PCR\n  # Assumes all operations in ops_by_master_mix hash are from the same program\n  #\n  # @param output_name [String] output name\n  # @param ops_by_master_mix [Hash{String =\u003e Array\u003cOperation\u003e}] hash of\n  #   operations grouped by tube labels\n  # @param composition [PCRComposition]\n  def dispense_master_mix(output_name:, ops_by_master_mix:, composition:, mult: 1.0)\n    coll = ops_by_master_mix.values.first.first.output(output_name).collection\n    coll_display = \"#{coll}-#{TEST}\"\n\n    mm_vol = composition.sum_added_components * mult\n    divide = composition.volume * mult \u003e 100\n\n    if divide\n      ops = ops_by_master_mix.values.flatten\n      labels = ops.map do |op|\n        coll_id_display(\n          op: op, handle: output_name,\n          role: 'output', hide_id: true\n          )\n      end\n      show do\n        title 'Divide Master Mix'\n\n        note \"Get #{ops.length} 1.5 ml microfuge tubes and label them\"\\\n             \" #{labels.to_sentence}\"\n      end\n    end\n\n    destination = divide ? 'microfuge tube' : \"#{coll_display} position\"\n\n    master_mix_table = []\n    master_mix_table[0] = [\n      'MM tube',\n      destination\n    ]\n\n    ops_by_master_mix.each do |master_mix, ops|\n      ops.each do |op|\n        pos = coll_id_display(\n          op: op, handle: output_name,\n          role: 'output', hide_id: true\n        )\n        row = [\n          master_mix,\n          { content: pos, check: true }\n        ]\n        master_mix_table.append(row)\n      end\n    end\n\n    show do\n      title 'Dispense Master Mix'\n      note \"Dispense #{mm_vol} #{MICROLITERS} of each master mix\"\\\n           \" into the indicated \u003cb\u003e#{destination}\u003c/b\u003e\"\n      table master_mix_table\n    end\n  end\n\n  # Dispenses a component\n  #\n  # @param input_name [String] input name of component\n  # @param output_name [String] output name\n  # @param ops [OperationList, Array\u003cOperation\u003e] operations\n  # @param composition [PCRComposition]\n  # @param mult [Float] Amount to multiply each component volume by to\n  #   account for pipetting error\n  def dispense_component(input_name:, output_name:, ops:, composition:, mult: 1.0)\n    coll = ops.first.output(output_name).collection\n    coll_display = \"#{coll}-#{TEST}\"\n\n    component = composition.input(input_name)\n    comp_vol = component.adjusted_qty(mult = mult, round = 1, checkable = false)\n\n    divide = composition.volume * mult \u003e 100\n    destination = divide ? 'microfuge tube' : \"#{coll_display} position\"\n\n    uniq_inputs = ops.map { |op| op.input(input_name).item }.uniq\n    if uniq_inputs.length == 1\n      from_header = \"#{uniq_inputs.first} position\"\n      hide_input_id = true\n    else\n      from_header = \"#{input_name} ID\"\n      hide_input_id = false\n    end\n\n    dispense_table = []\n    dispense_table[0] = [\n      from_header,\n      destination\n    ]\n\n    ops.each do |op|\n      from_pos = coll_id_display(\n        op: op, handle: input_name,\n        role: 'input', hide_id: hide_input_id\n      )\n      to_pos = coll_id_display(\n        op: op, handle: output_name,\n        role: 'output', hide_id: true\n      )\n      row = [from_pos, { content: to_pos, check: true }]\n      dispense_table.append(row)\n    end\n\n    show do\n      title \"Dispense #{input_name.pluralize}\"\n\n      if input_name.pluralize == 'Templates'\n\n        check \"Dispense #{comp_vol} #{MICROLITERS} of each template in\" \\\n          \" the indicated \u003cb\u003e#{destination}\u003c/b\u003e and close cap for each well\" \\\n          ' after template is added'\n        table dispense_table\n        note 'Vortex and spin down test stripwells'\n\n      else\n\n        check \"Dispense #{comp_vol} #{MICROLITERS} of each #{input_name}\"\\\n              \" into the indicated \u003cb\u003e#{destination}\u003c/b\u003e\"\n        table dispense_table\n\n      end\n    end\n  end\n\n  # Displays id / position for items that may be sub-items in collections\n  #\n  # @param op [Operation]\n  # @param handle [String] input or output name\n  # @param role [String] \"input\" or \"output\"\n  # @param hide_id [Boolean] whether to include the Collection ID\n  # @return [String] Item ID followed by location if a collection\n  def coll_id_display(op:, handle:, role: 'input', hide_id: false)\n    if role == 'input'\n      fv = op.input(handle)\n    elsif role == 'output'\n      fv = op.output(handle)\n    else\n      raise \"Unrecognized role: #{role}\"\n    end\n\n    display = hide_id ? '' : fv.item.to_s\n\n    if fv.item.collection?\n      row = fv.row\n      col = fv.column\n      row, col = fv.collection.find(fv.sample).first unless row \u0026\u0026 col\n      display += \" #{well_pos_display(row, col)}\"\n    end\n\n    display.strip\n  end\n\n  def well_pos_display(row, col)\n    alpha_r = ('A'..'H').to_a\n    \"#{alpha_r[row]}#{col + 1}\"\n  end\nend\n"}},{"library":{"name":"OperationErrors","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\nneeds 'PCR Libs/PCRCompositionDefinitions'\n\n# Factory class for instantiating `PCRComposition`\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass PCRCompositionFactory\n  # Instantiates `PCRComposition`\n  # Either `component_data` or `program_name` must be passed\n  #\n  # @param component_data [Hash] a hash enumerating the components\n  # @param program_name [String] the name of one of the default\n  #   component hashes\n  # @return [PCRComposition]\n  def self.build(component_data: nil, program_name: nil)\n    PCRComposition.new(\n      component_data: component_data,\n      program_name: program_name\n    )\n  end\nend\n\n# Models the composition of a polymerase chain reaction\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\n# @note As much as possible, Protocols using this class should draw\n#   input names from `CommonInputOutputNames`\nclass PCRComposition\n  include PCRCompositionDefinitions\n\n  attr_accessor :components\n\n  # Instantiates the class\n  # Either `component_data` or `program_name` must be passed\n  #\n  # @param component_data [Hash] a hash enumerating the components\n  # @param program_name [String] the name of one of the default\n  #   component hashes\n  # @return [PCRComposition]\n  def initialize(component_data: nil, program_name: nil)\n    if component_data.blank? \u0026\u0026 program_name.blank?\n      msg = 'Unable to initialize PCRComposition.' \\\n        ' Either `component_data` or `program_name` is required.'\n      raise ProtocolError, msg\n    elsif program_name.present?\n      component_data = get_composition_def(name: program_name)\n    end\n\n    @components = []\n    component_data.each { |_, c| components.append(ReactionComponent.new(c)) }\n  end\n\n  # Specifications for the dye component\n  # @return (see #input)\n  def dye\n    input(DYE)\n  end\n\n  # Specifications for the polymerase component\n  # @return (see #input)\n  def polymerase\n    input(POLYMERASE)\n  end\n\n  # Specifications for the forward primer component\n  # @return (see #input)\n  def forward_primer\n    input(FORWARD_PRIMER)\n  end\n\n  # Specifications for the reverse primer component\n  # @return (see #input)\n  def reverse_primer\n    input(REVERSE_PRIMER)\n  end\n\n  # Specifications for the template component\n  # @return [ReactionComponent]\n  def template\n    input(TEMPLATE)\n  end\n\n  # Specifications for the water component\n  # @return (see #input)\n  def water\n    input(WATER)\n  end\n\n  # Retrieves components by input name\n  # Generally the named methods should be used.\n  # However, this method can be convenient in loops, especially when\n  #   the Protocol draws input names from `CommonInputOutputNames`\n  #\n  # @param input_name [String] the name of the component to be retrieved\n  # @return [ReactionComponent]\n  def input(input_name)\n    components.find { |c| c.input_name == input_name }\n  end\n\n  # Displays the total reaction volume with units\n  #\n  # @todo Make this work better with units other than microliters\n  # @return [String]\n  def qty_display\n    Units.qty_display({ qty: volume, units: MICROLITERS })\n  end\n\n  # The total reaction volume\n  # @note Rounds to one decimal place\n  # @return [Float]\n  def volume\n    sum_components\n  end\n\n  # The total reaction volume\n  # @param round [Fixnum] the number of decimal places to round to\n  # @return [Float]\n  def sum_components(round = 1)\n    components.map(\u0026:qty).reduce(:+).round(round)\n  end\n\n  # The total volume of all components that have been added\n  # @param (see #sum_components)\n  # @return (see #sum_components)\n  def sum_added_components(round = 1)\n    added_components.map(\u0026:qty).reduce(:+).round(round)\n  end\n\n  # Gets the components that have been added\n  # @return [Array\u003cReactionComponent\u003e]\n  def added_components\n    components.select(\u0026:added?)\n  end\nend\n\n# Models a component of a biochemical reaction\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass ReactionComponent\n  include Units\n\n  attr_reader :input_name, :qty, :units, :sample, :item\n  attr_accessor :added\n\n  # Instantiates the class\n  #\n  # @param input_name [String] the name of the component\n  # @param qty [Numeric] the quantity of this component to be added to\n  #   a single reaction\n  # @param units [String] the units of `qty`\n  # @param sample_name [String] the name of the Aquarium Sample to be\n  #   used for this component\n  # @param object_name [String] the ObjectType (Container) that this\n  #   component should be found in\n  def initialize(input_name:, qty:, units:, sample_name: nil, object_name: nil)\n    @input_name = input_name\n    @qty = qty\n    @units = units\n    @sample = sample_name ? Sample.find_by_name(sample_name) : nil\n\n    @item = (sample.in(object_name).first if sample \u0026\u0026 object_name)\n\n    @added = false\n  end\n\n  # The input name, formatted for display in protocols\n  # @return [String]\n  def display_name\n    input_name\n  end\n\n  # Displays the volume (`qty`) with units\n  #\n  # @return [String]\n  def qty_display(round = 1)\n    Units.qty_display({ qty: qty.round(round), units: units })\n  end\n\n  # Adjusts the qty by a given factor and, if needed, makes it checkable\n  #   in a table\n  #\n  # @param mult [Float] the factor to multiply `qty` by\n  # @param round [FixNum] the number of places to round the result to\n  # @param checkable [Boolean] whether to make the result checkable\n  #   in a table\n  # @return [Numeric, Hash]\n  def adjusted_qty(mult = 1.0, round = 1, checkable = true)\n    adj_qty = (qty * mult).round(round)\n    adj_qty = { content: adj_qty, check: true } if checkable\n    adj_qty\n  end\n\n  # provides the `qty` for display in a table, and markes it as `added`\n  #\n  # @param (see #adjusted_qty)\n  # @return (see #adjusted_qty)\n  def add_in_table(mult = 1.0, round = 1, checkable = true)\n    @added = true\n    adjusted_qty(mult, round, checkable)\n  end\n\n  # Checks if `self` has been added\n  # @return [Boolean]\n  def added?\n    added\n  end\nend\n"}},{"library":{"name":"Pipettors","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\nneeds 'PCR Libs/PCRProgramDefinitions'\n\n# Factory class for instantiating `PCRProgram`\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass PCRProgramFactory\n  # Instantiates `PCRComposition`\n  #\n  # @param program_name [String] the name of one of the default program hashes\n  # @param volume [Numeric] the reaction volume in MICROLITERS\n  # @return [PCRProgram]\n  def self.build(program_name:, volume: nil)\n    PCRProgram.new(program_name: program_name, volume: volume)\n  end\nend\n\n# Models a thermocycler program\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass PCRProgram\n  include PCRProgramDefinitions\n\n  attr_reader :program_name, :program_template_name, :layout_template_name\n  attr_reader :steps, :volume\n\n  # Instantiates the class\n  #\n  # @param program_name [String] the name of one of the default program hashes\n  # @param volume [Numeric] the reaction volume in MICROLITERS\n  # @return [PCRProgram]\n  def initialize(args = {})\n    @program_name = args[:program_name]\n    program = get_program_def(name: program_name)\n    @program_template_name = program[:program_template_name]\n    @name = @program_template\n    @plate = program[:plate]\n    @layout_template_name = program[:layout_template_name]\n    @steps = {}\n    program[:steps].each { |k, v| @steps[k] = PCRStep.create_from(v) }\n    @volume = args[:volume] || program[:volume]\n  end\n\n  # @deprecated Use {#program_template_name}\n  def name\n    program_template_name\n  end\n\n  # @deprecated Use {#layout_template_name}\n  def plate\n    layout_template_name\n  end\n\n  # Renders the thermocycler program as a table for `show` blocks\n  #\n  # @return [Array\u003cArray\u003e]\n  def table\n    table = [%w[Step Temperature Duration]]\n    steps.each do |k, v|\n      row = [k.to_s] + v.display\n      table.append(row)\n    end\n    table\n  end\n\n  # TODO: This needs to be responsive to the actual program parameters\n  def final_step\n    'the final step'\n  end\nend\n\n# Models a step of a PCRProgram\n# Really a factory class that retruns a concrete Step class\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass PCRStep\n  def self.create_from(temperature: nil, duration: nil, goto: nil, times: nil)\n    if temperature \u0026\u0026 duration\n      IncubationStep.new(temperature: temperature, duration: duration)\n    elsif goto \u0026\u0026 times\n      GotoStep.new(destination: goto, times: times)\n    else\n      raise ProtocolError, 'Expected either an incubation or goto step'\n    end\n  end\nend\n\n# Models an incubation step\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass IncubationStep\n  attr_reader :temperature, :duration\n\n  def initialize(temperature:, duration:)\n    @temperature = temperature\n    @duration = duration\n  end\n\n  def display\n    [temperature_display, duration_display]\n  end\n\n  def temperature_display\n    Units.qty_display(temperature)\n  end\n\n  def duration_display\n    Units.qty_display(duration)\n  end\nend\n\n# Models a goto step\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nclass GotoStep\n  attr_reader :destination, :times\n\n  def initialize(destination:, times:)\n    @destination = destination\n    @times = times\n  end\n\n  def display\n    [goto_display, times_display]\n  end\n\n  def goto_display\n    \"goto step #{destination}\"\n  end\n\n  def times_display\n    \"#{times} times\"\n  end\nend\n"}},{"library":{"name":"PlanParams","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\n# Module for handling options passed to a `Plan` or to `Operations`\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nmodule PlanParams\n  # Gets `:options` from the `Plan` associations and the `Operations` and uses\n  #   them to override `default_job_params`\n  #\n  # @note\n  # @param operations [OperationList] the operations\n  # @param default_job_params [Hash] the default parameters to be applied\n  #   equally to all `Operations` in the `Job`\n  # @return [Hash] the updated parameters to be applied equally to all\n  #   `Operations` in the `Job`\n  def update_job_params(operations:, default_job_params:)\n    opts = strict_plan_options(operations)\n    job_params = update_plan_params(plan_params: default_job_params, opts: opts)\n    return job_params unless options_for?(operations)\n\n    update_from_operations(\n      operations: operations,\n      job_params: job_params\n    )\n  rescue IncompatibleParametersError =\u003e e\n    error_operations(operations: operations, err: e)\n  end\n\n  # Get Plan options from a list of Operations; raised an exception unless all\n  #   Operations come from the same Plan\n  #\n  # @param operations [Array\u003cOperation\u003e] the Operations\n  # @return [String] the options\n  def strict_plan_options(operations)\n    plans = operations.map(\u0026:plan).uniq\n\n    if plans.length \u003e 1\n      plan_ids = plans.map(\u0026:id)\n      msg = 'Operations must all be from a single Plan.' \\\n      \" #{plan_ids.length} Plans found: #{plan_ids.to_sentence}\"\n      raise IncompatibleParametersError, msg\n    end\n\n    operations.first.plan.associations[:options]\n  end\n\n  # Check to see if any of the `Operations` have `Options` set\n  #\n  def options_for?(operations)\n    operations.any? { |op| op.input('Options').try(:val).present? }\n  end\n\n  # Updates a hash from options\n  #\n  # @param plan_params [Hash] the receiver hash\n  # @param opts [Hash] the donatng hash\n  # @return [Hash]\n  # @deprecate Use {#update_params} instead\n  def update_plan_params(plan_params:, opts:)\n    update_params(default_params: plan_params, opts: opts)\n  end\n\n  # Updates a hash from options\n  #\n  # @param default_params [Hash] the receiver hash\n  # @param opts [Hash] the donatng hash\n  # @return [Hash]\n  def update_params(default_params:, opts:)\n    default_params.update(parse_options(opts)) if opts.present?\n    default_params\n  end\n\n  # Parses JSON formatted options\n  #\n  # @param opts [String] JSON-formatted string\n  # @return [Hash]\n  def parse_options(opts)\n    JSON.parse(opts, { symbolize_names: true })\n  end\n\n  # Gets `Options` from each `Operation` and uses them to update\n  #   `default_operation_params`, then applies the result to each\n  #   `Operation` at `op.temporary[:options]`\n  #\n  # @param operations [OperationList] the operations\n  # @param default_operation_params [Hash] the default parameters to be applied\n  #   to all `Operations` in the `Job` UNLESS overriden by input 'Options'\n  # @return [void]\n  def update_operation_params(operations:, default_operation_params:)\n    operations.each do |op|\n      opts = default_operation_params.dup.update(op.input('Options').val)\n      op.temporary[:options] = opts\n    end\n  end\n\n  # Convenience method for calling both {#update_job_params} and\n  #   {#update_operation_params}\n  #\n  # @param operations [OperationList] the operations\n  # @param default_job_params [Hash] the default parameters to be applied\n  #   equally to all `Operations` in the `Job`\n  # @param default_operation_params [Hash] the default parameters to be applied\n  #   to all `Operations` in the `Job` UNLESS overriden by input 'Options'\n  # @return [Hash] the updated parameters to be applied to all\n  #   `Operations` in the `Job`\n  def update_all_params(operations:, default_job_params:,\n                        default_operation_params:)\n    job_params = update_job_params(\n      operations: operations,\n      default_job_params: default_job_params\n    )\n    update_operation_params(\n      operations: operations,\n      default_operation_params: default_operation_params\n    )\n    job_params\n  end\n\n  ########## TESTING METHODS ##########\n\n  TEST_PARAMS = {\n    who_is_on_first: false\n  }.freeze\n\n  # Set everything up for testing using options\n  #\n  # @param operations [OperationList] the operations\n  # @param options [Hash] the options\n  # @return [void]\n  def setup_test_options(operations:, opts: TEST_PARAMS)\n    associate_plan_options(operations: operations, opts: opts)\n    unify_plans(operations: operations)\n  end\n\n  # Add options to the `Plan` for testing purposes\n  #\n  # @param operations [OperationList] the operations\n  # @param options [Hash] the options\n  # @return [void]\n  def associate_plan_options(operations:, opts:)\n    plan = operations.first.plan\n    plan.associate(:options, opts.to_json)\n  end\n\n  # Make all operations have the same plan\n  #\n  # @param operations [OperationList] the operations\n  # @return [void]\n  def unify_plans(operations:)\n    plan_associations = operations.map { |op| op.plan_associations.first }\n    plan = operations.first.plan\n    plan_associations.each do |pa|\n      pa.plan = plan\n      pa.save\n    end\n\n    # Needed to refresh plan associations for weird Rails reasons\n    Operation.find(operations.map(\u0026:id))\n  end\n\n  # Get an option value for a given key from the given operation\n  #\n  def get_options(operations:, key:)\n    operations.map { |op| get_option(operation: op, key: key) }\n  end\n\n  # Get an option value for a given key from the given operation\n  #\n  def get_option(operation:, key:)\n    operation.input('Options').val.fetch(key, :no_key)\n  end\n\n  private\n\n  # Update job_params based on options for the given operations\n  #\n  def update_from_operations(operations:, job_params:)\n    job_params.keys.each do |key|\n      val = strict_operations_option(operations: operations, key: key)\n      job_params[key] = val unless val == :no_key\n    end\n    job_params\n  end\n\n  # Get a list of option values for a given key from the given operations list,\n  #   or raise exception if there is more than one unique value\n  #\n  def strict_operations_option(operations:, key:)\n    val = get_options(operations: operations, key: key)\n    unless val.uniq.length == 1\n      msg = \"More than one value given in Operation Options for #{key}:\" \\\n            \" #{val}\"\n      raise IncompatibleParametersError, msg\n    end\n    val.first\n  end\n\n  # Say you're quitting due to an error and error all the operations\n  #\n  def error_operations(operations:, err:)\n    show do\n      title 'Incompatible Parameters Detected'\n      warning err.message\n    end\n\n    operations.each { |op| op.error(:incompatible_parameters, err.message) }\n  end\n\n  class IncompatibleParametersError \u003c ProtocolError; end\nend\n"}},{"library":{"name":"Preconditions","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\nneeds 'Standard Libs/Units'\nneeds 'Standard Libs/CommonInputOutputNames'\n\n# Provice composition definitions for PCR reactions\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nmodule PCRCompositionDefinitions\n  include Units\n  include CommonInputOutputNames\n\n  POLYMERASE = 'Polymerase'\n  DYE = 'Dye'\n  WATER = 'Molecular Grade Water'\n  MASTER_MIX = 'Master Mix'\n  PRIMER_PROBE_MIX = 'Combined Primer/Probe Mix'\n\n  COMPONENTS = {\n    # qPCR2: 2nd qPCR in NGS prep.\n    'qPCR1' =\u003e {\n      polymerase: {\n        input_name: POLYMERASE,\n        qty: 16, units: MICROLITERS,\n        sample_name: 'Kapa HF Master Mix',\n        object_name: 'Enzyme Stock'\n      },\n      forward_primer: {\n        input_name: FORWARD_PRIMER,\n        qty: 0.16,  units: MICROLITERS\n      },\n      reverse_primer: {\n        input_name: REVERSE_PRIMER,\n        qty: 0.16,  units: MICROLITERS\n      },\n      dye: {\n        input_name: DYE,\n        qty: 1.6, units: MICROLITERS,\n        sample_name: 'Eva Green',\n        object_name: 'Screw Cap Tube'\n      },\n      water: {\n        input_name: WATER,\n        qty: 6.58, units: MICROLITERS\n      },\n      template: {\n        input_name: TEMPLATE,\n        qty: 7.5, units: MICROLITERS\n      }\n    },\n\n    # qPCR2: 2nd qPCR in NGS prep.\n    #   Reverse primer is indexed primer.\n    'qPCR2' =\u003e {\n      polymerase: {\n        input_name: POLYMERASE,\n        qty: 25, units: MICROLITERS,\n        sample_name: 'Kapa HF Master Mix',\n        object_name: 'Enzyme Stock'\n      },\n      forward_primer: {\n        input_name: FORWARD_PRIMER,\n        qty: 2.5, units: MICROLITERS\n      },\n      reverse_primer: {\n        input_name: REVERSE_PRIMER,\n        qty: 2.5, units: MICROLITERS\n      },\n      dye: {\n        input_name: DYE,\n        qty: 2.5, units: MICROLITERS,\n        sample_name: 'Eva Green',\n        object_name: 'Screw Cap Tube'\n      },\n      water: {\n        input_name: WATER,\n        qty: 15.5, units: MICROLITERS\n      },\n      template: {\n        input_name: TEMPLATE,\n        qty: 2, units: MICROLITERS\n      }\n    },\n\n    # LIBqPCR1: 1st qPCR in Libray prep.\n    #   If sublibrary primers exist they are used here.\n    'lib_qPCR1' =\u003e {\n      polymerase: {\n        input_name: POLYMERASE,\n        qty: 12.5, units: MICROLITERS,\n        sample_name: 'Kapa HF Master Mix',\n        object_name: 'Enzyme Stock'\n      },\n      forward_primer: {\n        input_name: FORWARD_PRIMER,\n        qty: 0.75, units: MICROLITERS\n      },\n      reverse_primer: {\n        input_name: REVERSE_PRIMER,\n        qty: 0.75, units: MICROLITERS\n      },\n      dye: {\n        input_name: DYE,\n        qty: 1.25, units: MICROLITERS,\n        sample_name: 'Eva Green',\n        object_name: 'Screw Cap Tube'\n      },\n      water: {\n        input_name: WATER,\n        qty: 8.75, units: MICROLITERS\n      },\n      template: {\n        input_name: TEMPLATE,\n        qty: 1, units: MICROLITERS\n      }\n    },\n\n    # LIBqPCR2: 2nd qPCR in Libray prep.\n    #   Overhangs compatible with cloning vector are added here.\n    'lib_qPCR2' =\u003e {\n      polymerase: {\n        input_name: POLYMERASE,\n        qty: 25, units: MICROLITERS,\n        sample_name: 'Kapa HF Master Mix',\n        object_name: 'Enzyme Stock'\n      },\n      forward_primer: {\n        input_name: FORWARD_PRIMER,\n        qty: 1.5, units: MICROLITERS\n      },\n      reverse_primer: {\n        input_name: REVERSE_PRIMER,\n        qty: 1.5, units: MICROLITERS\n      },\n      dye: {\n        input_name: DYE,\n        qty: 2.5, units: MICROLITERS,\n        sample_name: 'Eva Green',\n        object_name: 'Screw Cap Tube'\n      },\n      water: {\n        input_name: WATER,\n        qty: 17.5, units: MICROLITERS\n      },\n      template: {\n        input_name: TEMPLATE,\n        qty: 2, units: MICROLITERS\n      }\n    },\n\n    # CDC COVID-19 detection protocol\n    'CDC_TaqPath_CG' =\u003e {\n      water: {\n        input_name: WATER,\n        qty: 8.5, units: MICROLITERS\n      },\n      primer_probe_mix: {\n        input_name: PRIMER_PROBE_MIX,\n        qty: 1.5, units: MICROLITERS\n      },\n      master_mix: {\n        input_name: MASTER_MIX,\n        qty: 5.0, units: MICROLITERS,\n        sample_name: 'TaqPath 1-Step RT-qPCR Master Mix (4x)'\n      },\n      template: {\n        input_name: TEMPLATE,\n        qty: 5.0, units: MICROLITERS\n      }\n    },\n\n    # CDC COVID-19 detection protocol\n    'CDC_qScript_XLT_ToughMix' =\u003e {\n      water: {\n        input_name: WATER,\n        qty: 3.5, units: MICROLITERS\n      },\n      primer_probe_mix: {\n        input_name: PRIMER_PROBE_MIX,\n        qty: 1.5, units: MICROLITERS\n      },\n      master_mix: {\n        input_name: MASTER_MIX,\n        qty: 10, units: MICROLITERS,\n        sample_name: 'qScript XLT One-Step RT-qPCR ToughMix (2X)'\n      },\n      template: {\n        input_name: TEMPLATE,\n        qty: 5.0, units: MICROLITERS\n      }\n    },\n\n    # CDC COVID-19 detection protocol\n    'CDC_UltraPlex_ToughMix' =\u003e {\n      water: {\n        input_name: WATER,\n        qty: 8.5, units: MICROLITERS\n      },\n      primer_probe_mix: {\n        input_name: PRIMER_PROBE_MIX,\n        qty: 1.5, units: MICROLITERS\n      },\n      master_mix: {\n        input_name: MASTER_MIX,\n        qty: 5.0, units: MICROLITERS,\n        sample_name: 'UltraPlex 1-Step ToughMix (4X)'\n      },\n      template: {\n        input_name: TEMPLATE,\n        qty: 5.0, units: MICROLITERS\n      }\n    },\n\n    # CDC COVID-19 detection protocol\n    'CDC_GoTaq_Probe_1-Step' =\u003e {\n      water: {\n        input_name: WATER,\n        qty: 3.1, units: MICROLITERS\n      },\n      primer_probe_mix: {\n        input_name: PRIMER_PROBE_MIX,\n        qty: 1.5, units: MICROLITERS\n      },\n      master_mix: {\n        input_name: MASTER_MIX,\n        qty: 10, units: MICROLITERS,\n        sample_name: 'GoTaq Probe qPCR Master Mix with dUTP'\n      },\n      rt_mix: {\n        input_name: 'RT Mix',\n        qty: 0.4, units: MICROLITERS,\n        sample_name: 'Go Script RT Mix for 1-Step RT-qPCR'\n      },\n      template: {\n        input_name: TEMPLATE,\n        qty: 5.0, units: MICROLITERS\n      }\n    }\n  }.freeze\n\n  private_constant :COMPONENTS\n\n  # Gets the Hash that defines the compostion for the given name\n  #\n  # @param name [String]\n  # @return [Hash]\n  def get_composition_def(name:)\n    COMPONENTS[name]\n  end\nend\n"}},{"library":{"name":"PrinterHelper","category":"Standard Libs","code_source":"# SG\n# module for label printer\nmodule PrinterHelper\n    \n    #------------------------------------------\n    # print labels for samples\n    # inputs:\n    # ioStrs - array of strings, output items\n    #------------------------------------------\n    def printLabels(ioStrs)\n\n        min_id=Float::INFINITY\n        max_id=0 \n        \n        if(!ioStrs.kind_of?(Array)) # make sure input is an array\n            ioStrs=[ioStrs]\n        end\n        \n        show do\n            title \"Use label printer to label new 1.5 mL tubes with the following numbers:\"\n            operations.each { |op|\n                ioStrs.each { |ioStr|\n                    note \"#{op.output(ioStr).item}\"\n                    min_id=[op.output(ioStr).item.id, min_id].min\n                    max_id=[op.output(ioStr).item.id, max_id].max\n                }\n            }\n            check \"Ensure that the B33-143-492 labels are loaded in the printer. This number should be displayed on the printer. If not, check with a lab manager.\"\n            check \"Open the LabelMark 6 software.\"\n            check \"Select \u003cb\u003eOpen \u003c/b\u003e --\u003e \u003cb\u003eFile\u003c/b\u003e --\u003e \u003cb\u003eSerialized data top labels\u003c/b\u003e\"\n            note \"If an error about the printer appears, press \u003cb\u003eOkay\u003c/b\u003e\"\n            check \"Select the first label graphic, and click on the number in the middle of the label graphic.\"\n            check \"On the toolbar on the left, select \u003cb\u003eEdit serialized data\u003c/b\u003e\"\n            if(max_id-min_id+1 == operations.length*ioStrs.length) # consecutive numbers\n                check \"Enter \u003cb\u003e#{min_id}\u003c/b\u003e for the Start number and \u003cb\u003e#{operations.length*ioStrs.length}\u003c/b\u003e for the Total number, and select \u003cb\u003eFinish\u003c/b\u003e\"\n            else\n                check \"Enter the listed numbers manually and select \u003cb\u003eFinish\u003c/b\u003e\"\n            end\n            check \"Select \u003cb\u003eFile\u003c/b\u003e --\u003e \u003cb\u003ePrint\u003c/b\u003e and select \u003cb\u003eBBP33\u003c/b\u003e as the printer option.\"\n            check \"Press \u003cb\u003ePrint\u003c/b\u003e and collect the labels.\"\n            image \"purify_gel_edit_serialized_data\"\n            image \"Actions/purify_gel/purify_gel_sequential\"\n        end\n    end # def\n    \nend # module"}},{"library":{"name":"Priority Queue","category":"Standard Libs","code_source":"class PriorityQueue \n  def initialize\n    @heap = Heap.new()\n    @priority_map = Hash.new()\n  end\n\n  def empty?\n    @heap.empty?\n  end\n\n  def has_key?(key)\n    @priority_map.has_key?(key)\n  end\n\n  def push(key, priority)\n    node = PriorityNode.new(value: key, priority: priority)\n    @priority_map[key] = priority\n    @heap.add!(node)\n  end\n\n  def each(\u0026blk)\n    @priority_map.each(\u0026blk)\n  end\n\n  def min\n    @heap.peek.to_pair\n  end\n\n  def min_key\n    return nil if empty?\n\n    @heap.peek.value\n  end\n\n  def min_priority\n    return nil if empty?\n\n    @heap.peek.priority\n  end\n\n  # remove min and return pair\n  def delete_min\n    return nil if empty?\n\n    min_node = @heap.remove!\n    @priority_map.delete(min_node.value)\n    min_node.to_pair\n  end\n\n  # remove min and return key\n  def delete_min_return_key\n    return nil if empty?\n\n    min_value = @heap.remove!.value\n    @priority_map.delete(min_value)\n    min_value\n  end\n\n  private\n\n  class PriorityNode\n    include Comparable\n    attr_reader :value, :priority\n\n    def initialize(value:, priority:)\n      @value = value\n      @priority = priority\n    end\n\n    def \u003c=\u003e(node)\n      @priority \u003c=\u003e node.priority\n    end\n\n    def to_pair\n      [@value, @priority]\n    end\n  end\n\nend\n\n# Based on https://cs.lmu.edu/~ray/notes/pqueues/\nclass Heap\n  def initialize\n    @heap = []\n  end\n\n  def add!(x)\n    @heap.append(x)\n    sift_up(@heap.length - 1)\n    self\n  end\n\n  def empty?\n    @heap.length == 0\n  end\n\n  def peek\n    @heap[0]\n  end\n\n  def remove!\n    return nil if empty?\n\n    value = @heap[0]\n    if @heap.length == 1\n      @heap = []\n    else\n      @heap[0] = @heap.pop\n      sift_down(0)\n    end\n    value\n  end\n\n  def to_s\n    @heap.to_s\n  end\n\n  private\n\n  # Sift up the element at index i\n  def sift_up(i)\n    parent = (i - 1) / 2\n    if parent \u003e= 0 and @heap[parent] \u003e @heap[i]\n      @heap[parent], @heap[i] = @heap[i], @heap[parent]\n      sift_up(parent)\n    end\n  end\n\n  # Sift down the element at index i\n  def sift_down(i)\n    child = (i * 2) + 1\n    return if child \u003e= @heap.length\n    child += 1 if child + 1 \u003c @heap.length and @heap[child] \u003e @heap[child+1]\n    if @heap[i] \u003e @heap[child]\n      @heap[child], @heap[i] = @heap[i], @heap[child]\n      sift_down(child)\n    end\n  end\nend"}},{"library":{"name":"ProvenanceFinder","category":"Standard Libs","code_source":"module ProvenanceFinder\n    # Finds output FieldValues for a given Item id.\n    #\n    # @param item_id [int] id of an Item\n    # @return [ActiveRecord::Relation] FieldValues\n    def output_fvs(item_id)\n        FieldValue.where(role: 'output', child_item_id: item_id) || []\n    end\n\n    # Finds input FieldValues for a given Item id.\n    #\n    # @param item_id [int] id of an Item\n    # @return [ActiveRecord::Relation] FieldValues\n    def input_fvs(item_id)\n        FieldValue.where(role: 'input', child_item_id: item_id) || []\n    end\n\n    # Finds Operations for which a given Item is an output.\n    #\n    # @param item_id [int] id of an Item\n    # @return [Array] Operations that produced this item\n    def predecessor_ops(item_id)\n        output_fvs(item_id).map { |fv| fv.operation }\n    end\n\n    # Finds Operations for which a given Item is an input.\n    #\n    # @param item_id [int] id of an Item\n    # @return [Array] Operations that used this item as input\n    def successor_ops(item_id)\n        input_fvs(item_id).map { |fv| fv.operation }\n    end\n\n    # Recursively finds the Operation backchain for a given item.\n    # Goes back to a specified OperationType, then stops.\n    #\n    # @param stop_at [string] name of the OperationType of the Operation to stop at\n    # @param item_id [int] id of an Item\n    # @param row [string] the row location if the Item is a collection\n    # @param column [string] the column location if the Item is a collection\n    # @param ops [Array] the list of operations to be returned\n    # @return [Array] the Operation backchain\n    def walk_back(stop_at, item_id, row=nil, col=nil, ops=nil)\n        ops ||= []\n\n        pred_fvs = output_fvs(item_id)\n        pred_fvs = pred_fvs.select { |fv| fv.row == row and fv.column == col }\n\n        return ops unless pred_fvs.present?\n\n        op_ids = ops.flatten.map { |op| op.id }\n        pred_op_fvs = pred_fvs.select { |fv| fv.parent_class == \"Operation\" \u0026\u0026 ! op_ids.include?(fv.parent_id) }\n        pred_op_ids = pred_op_fvs.map { |fv| fv.parent_id }\n        pred_ops = Operation.where(id: pred_op_ids)\n        # It's not clear to me why this should happen\n        return ops unless pred_ops.present?\n\n        pred_op = pred_ops.sort_by { |op| job_completed(op) }.first\n        ops.append(pred_op)\n\n        return ops if pred_op.operation_type.name == stop_at\n\n        begin\n            input_fv = get_input_fv(pred_op, item_id)\n\n        rescue InputNotFoundError =\u003e e\n            puts e.message\n            return ops\n        end\n\n        if input_fv.field_type.array == true\n            branches = []\n            pred_op.input_array(input_fv.name).each do |fv|\n                branches.append(walk_back(stop_at, fv.child_item_id, fv.row, fv.column))\n            end\n            ops.append(branches)\n        end\n\n        return walk_back(stop_at, input_fv.child_item_id, input_fv.row, input_fv.column, ops)\n    end\n\n    # Gets the completion date for the most recent Job for a given Operation.\n    #\n    # @param op [Operation]\n    # @return [DateTime]\n    def job_completed(op)\n        jobs = op.jobs.sort_by { |job| job.updated_at }\n        jobs.last.updated_at\n    end\n\n    # Determines the most likely input FieldValue for a given Operation and output Item.\n    #\n    # @param op [Operation] the Operation to search within\n    # @param output_item_id [int] the id of the output Item\n    # @return [FieldValue] the most likely input\n    def get_input_fv(op, output_item_id)\n        # If only one input, then the answer is obvious\n        inputs = op.inputs\n        return inputs[0] if inputs.length == 1\n\n        # If more than one input, then it attempts to use routing\n        routing_matches = get_routing_matches(op, output_item_id)\n        return routing_matches[0] if routing_matches.present?\n\n        # If no routing (bad developer!) then it attempts to match Sample name\n        sample_name_matches = get_sample_name_matches(op, output_item_id)\n        return sample_name_matches[0] if sample_name_matches.present?\n\n        # Gives up\n        raise InputNotFoundError.new(\n            \"No input for output item #{output_item_id} in operation #{op.id}.\"\n        )\n    end\n\n    # Returns input FieldValues for the given Operation with the same routing as the given output Item\n    #\n    # @param op [Operation]\n    # @param output_item_id [int]\n    # @return [Array] input FieldValues that have the same routing as the output\n    def get_routing_matches(op, output_item_id)\n        fvs = FieldValue.where(\n            role: 'output',\n            parent_id: op.id,\n            parent_class: 'Operation',\n            child_item_id: output_item_id\n        )\n\n        fv = fvs.last\n        op.inputs.select { |i| i.field_type \u0026\u0026 i.field_type.routing == fv.field_type.routing }\n    end\n\n    # Returns input FieldValues for the given Operation with the same Sample name as the given output Item\n    #\n    # @param op [Operation]\n    # @param output_item_id [int]\n    # @return [Array] input FieldValues that have the same sample name as the output\n    def get_sample_name_matches(op, output_item_id)\n        sn = Item.find(output_item_id).sample.name\n        return op.inputs.select { |i| i.sample \u0026\u0026 i.sample.name == sn }\n    end\nend\n\nclass InputNotFoundError \u003c StandardError\n    def message\n        \"Could not find an input for this operation\"\n    end\nend\n\nclass NoPredecessorsError \u003c StandardError\n    def message\n        \"No predecessor was found where one was expected\"\n    end\nend"}},{"library":{"name":"SortHelper","category":"Standard Libs","code_source":"# SG\n# functions for sorting operations\n# \n# used in Library Cloning/Streak Plates on Media\nmodule SortHelper\n    \n    #-----------------------------------------------------------------------------\n    # sort ops by more than one input/output attribute, at io or item level \n    # algorithm: \n    # all possible unique values 1..n are sorted lexicographically and assigned numbers [1..n]\n    # attributes add value in powers of ops.length**(k), where k is the REVERSE position of the attribute in the matrix. \n    # (most important == first.) \n    # ops.length insures that the first level is high enough \n    #-----------------------------------------------------------------------------\n    def sortByMultipleIO(ops, ioStrs, ioNames, attributeStrs, itemLevels)\n        \n        allVals_mat=Array.new()\n        ioStrs.each_with_index { |ioStr, i|\n            allVals=[]\n            keys=[]\n            hash=Hash.new()\n            caseArray=[ioStrs[i],itemLevels[i]]\n            case caseArray\n            when [\"in\",\"io\"]\n                allVals = ops.map { |op| op.input(ioNames[i]).send(attributeStrs[i]) } \n            when [\"in\",\"item\"]\n                allVals = ops.map { |op| op.input(ioNames[i]).item.send(attributeStrs[i]) } \n            when [\"in\",\"val\"]\n                allVals = ops.map { |op| op.input(ioNames[i]).val } \n            when [\"in\",\"collection\"]\n                allVals = ops.map { |op| op.input(ioNames[i]).collection.send(attributeStrs[i]) } \n            when [\"out\",\"io\"]\n                allVals = ops.map { |op| op.output(ioNames[i]).send(attributeStrs[i]) } \n            when [\"out\",\"item\"]\n                allVals = ops.map { |op| op.output(ioNames[i]).item.send(attributeStrs[i]) } \n            when [\"out\",\"val\"]\n                allVals = ops.map { |op| op.output(ioNames[i]).val } \n            when [\"out\",\"collection\"]\n                allVals = ops.map { |op| op.output(ioNames[i]).collection.send(attributeStrs[i]) } \n            else\n                raise \"Bad ioStr #{ioStr} in #{__method__.to_s}, please check!\"\n            end\n            \n            begin\n                keys=allVals.uniq.sort \n            rescue\n                raise \"Can't sort [#{ioStrs[i]},#{itemLevels[i]}] in \u003cb\u003e#{__method__.to_s}\u003c/b\u003e, please check!\"\n            end\n            \n            values=Array (0..keys.length-1)\n            values.map! {|v| v=v*( (ops.length+1)**(ioStrs.length - i) ) }\n            hash=Hash[keys.zip(values)]\n            allVals_mat[i]=hash\n        }\n        \n        ops.sort! { |a, b| sortVal(a, ioStrs, ioNames, attributeStrs, itemLevels, allVals_mat)  \u003c=\u003e sortVal(b, ioStrs, ioNames, attributeStrs, itemLevels, allVals_mat) }\n        return ops\n    end # def\n  \n    #-----------------------------------------------------------------------------\n    # get op value for sort  \n    #-----------------------------------------------------------------------------\n    def sortVal(op, ioStrs, ioNames, attributeStrs, itemLevels, allVals_mat)\n        val = 0\n        allVals_mat.each_with_index { |hash, i|\n            case [ioStrs[i],itemLevels[i]]\n            when [\"in\",\"io\"]\n                val += hash[op.input(ioNames[i]).send(attributeStrs[i])]\n            when [\"in\",\"item\"]\n                val += hash[op.input(ioNames[i]).item.send(attributeStrs[i])] \n            when [\"in\",\"val\"]\n                val += hash[op.input(ioNames[i]).val] \n            when [\"in\",\"collection\"]\n                val += hash[op.input(ioNames[i]).collection.send(attributeStrs[i])] \n            when [\"out\",\"io\"]\n                val += hash[op.output(ioNames[i]).send(attributeStrs[i])] \n            when [\"out\",\"item\"]\n                val += hash[op.output(ioNames[i]).item.send(attributeStrs[i])] \n            when [\"out\",\"val\"]\n                val += hash[op.output(ioNames[i]).val] \n            when [\"out\",\"collection\"]\n                val += hash[op.output(ioNames[i]).collection.send(attributeStrs[i])] \n            else\n                raise \"Bad input [#{ioStrs[i]},#{itemLevels[i]}] in \u003cb\u003e#{__method__.to_s}\u003c/b\u003e, please check!\"\n            end\n        }\n        return val\n    end # def\n     \nend # module"}},{"library":{"name":"TemporaryTubeLabels","category":"Standard Libs","code_source":"# Library for handling temporary tube labels used during operations.\n#\n# Assigns simplified labes to the OUTPUT Item of each operation.\n# The basic method labels them as `[1,2,3,...]`, but this can be overridden.\nmodule TemporaryTubeLabels\n    def txfr_tube_labels(op, in_handle, out_handle)\n        op.output(out_handle).item.associate :sample_tube_label, op.input(in_handle).item.associations[:sample_tube_label]\n    end\n\n    def sample_tube_label(obj, handle=nil)\n        tube_label(obj, 'sample', handle)\n    end\n\n    def treatment_tube_label(obj, handle=nil)\n        tube_label(obj, 'treatment', handle)\n    end\n\n    def tube_label(obj, type, handle=nil)\n        item = handle ? obj.output(handle).item : obj\n        item.associations[\"#{type}_tube_label\".to_sym]\n    end\n\n    def tube_label_display(type, handle)\n      labels = operations.map { |op| tube_label(op, type, handle) }\n      case labels.length\n      when 1\n        labels[0]\n      when 2..5\n        labels.join(\", \")\n      else\n        \"#{labels.min}-#{labels.max}\"\n      end\n    end\n\n    def associate_sample_tube_labels(handle)\n        associate_tube_labels('sample', handle)\n    end\n\n    # Assigns an incremental tube number for each output\n    #\n    def associate_tube_labels(type, handle)\n        operations.each_with_index do |op, i|\n            op.output(handle).item.associate(\"#{type}_tube_label\".to_sym, \"#{i + 1}\")\n        end\n    end\nend"}},{"library":{"name":"Units","category":"Standard Libs","code_source":"module Units\n    \n    EMPTY = -1\n    \n    # Volume\n    MICROLITERS = 'ul'\n    MILLILITERS = 'ml'\n    \n    # Weight\n    NANOGRAMS = 'ng'\n    MICROGRAMS = 'g'\n    \n    # Concentration\n    PICOMOLAR = 'pM'\n    NANOMOLAR = 'nM'\n    MICROMOLAR = 'M'\n    MILLIMOLAR = 'mM'\n    MOLAR = 'M'\n    \n    # Temperature\n    DEGREES_C = 'C'\n    \n    # Time\n    MINUTES = 'min'\n    SECONDS = 'sec'\n    HOURS ='hr'\n    # Force\n    TIMES_G = 'x g'\n    \n    # R/DNA Length\n    BASEPAIRS = 'bp'\n    KILOBASEPAIRS = 'kbp'\n    MEGABASEPAIRS = 'mbp'\n    GIGABASEPAIRS = 'gbp'\n    \n    # Voltage\n    VOLTS = 'V'\n\n    def self.qty_display(qty)\n        \"#{qty[:qty]} #{qty[:units]}\"\n    end\n    \n    def qty_display(qty)\n        \"#{qty[:qty]} #{qty[:units]}\"\n    end\n    \n    def add_qty_display(options)\n        new_items = {}\n        \n        options.each do |key, value|\n            key =~ /^(.+_)+([a-z]+)$/\n            \n            case $2\n            when 'microliters'\n                units = MICROLITERS\n            when 'milliliters'\n                units = MILLILITERS\n            when 'minutes'\n                units = MINUTES\n            else\n                next\n            end\n            \n            qty = value.to_f\n            \n            new_items[\"#{$1}qty\".to_sym] = { qty: qty, units: units }\n        end\n        \n        options.update(new_items)\n    end\n    \n    # Return the unit constant for the the unit name if there is one.\n    #\n    # @param unit_name [String] the name of the unit\n    # @returns the value of the constant with the given name\n    # @raises BadUnitNameError if the name is not the name of a defined unit\n    def self.get_unit(unit_name:)\n        self.const_get(unit_name.upcase)\n      rescue\n        raise BadUnitNameError.new(name: unit_name)\n    end\n    \n    # Exception class for bad unit name arguments to Units::get_unit.\n    #\n    # @attr_reader [String] name  the bad unit name\n    class BadUnitNameError \u003c StandardError\n        attr_reader :name\n        \n        def initialize(msg: \"Unknown unit name\", name:)\n            @name = name\n            super(msg)\n        end\n    end\n    \n    # Return a key for the measure hash defined on the given object type.\n    #\n    # The measure hash must be defined in the data proerty of the object type as JSON.\n    # For instance\n    #\n    #   { \"measure\": { \"type\": \"concentration\", \"unit\": \"micromolar\" } }\n    #\n    # The key is constructed as the type name, an underscore, and the unit name.\n    #\n    # @param object_type [ObjectType] the object type\n    # @returns the key for the measure of the the object type if there is one\n    # @raises MissingObjectTypeMeasure if the object type has no measure data_object\n    def self.get_measure_key(object_type:)\n        data_object = object_type.data_object\n        raise MissingObjectTypeMeasureError.new(name: object_type.name) if !data_object.key?(:measure)\n        \n        measure = object_type.data_object[:measure]\n        type_name = measure[:type]\n        unit_name = measure[:unit]\n        \"#{type_name}_#{self.get_unit(unit_name: unit_name)}\"\n    end\n    \n    # Exception class for an object type with out a measure hash definition.\n    #\n    # @attr_reader [String] name  the name of the object type where measure has was expected\n    class MissingObjectTypeMeasureError \u003c StandardError\n        attr_reader :name\n        \n        def initialize(msg: \"ObjectType has no measure in data object\", name:)\n            @name = name\n            super(msg)\n        end\n    end\n   \nend"}},{"library":{"name":"UploadHelper","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\n# helper function for uploading files\n# note: data associations should be handled externally\nmodule UploadHelper\n\n  require 'csv'\n  require 'open-uri'\n\n  CSV_KEY = 'upload_csv'\n\n  #\n  # @param dirname - directory where files are located, or full path including filename\n  # @param exp_upload_num - expected number of files to upload\n  # @param tries - max. number of attempts to upload expectedNum files\n  #\n  # @returns array of Upload items\n  #\n  # EXAMPLES of how to associate correctly:\n  # data associations - 1st gel image\n  # up_bef=ups[0]\n  # op.plan.associate 'gel_image_bef', 'combined gel fragment', up_bef  # upload association, link\n  # op.input(INPUT).item.associate 'gel_image_bef', up_bef              # regular association\n  # op.output(OUTPUT).item.associate 'gel_image_bef', up_bef            # regular association\n  #------------------------------------------\n  def upload_data(dirname, exp_upload_num, tries)\n    uploads = {} # result of upload block\n    number_of_uploads = 0 # number of uploads in current attempt\n    attempt = 0 # number of upload attempts\n\n    loop do\n      # if(number_of_uploads==exp_upload_num)\n      # show {note 'Upload complete.'}\n      # end\n      break if (attempt \u003e= tries) || (number_of_uploads == exp_upload_num)\n\n      attempt += 1\n\n      uploads = show do\n        title \"Select \u003cb\u003e#{exp_upload_num}\u003c/b\u003e file(s)\"\n        note \"File(s) location is: #{dirname}\"\n        if attempt \u003e 1\n          warning \"Number of uploaded files (#{number_of_uploads}) was incorrect, please try again! (Attempt #{attempt} of #{tries})\"\n        end\n        upload var: 'files'\n      end\n      # number of uploads\n      if !uploads[:files].nil?\n        number_of_uploads = uploads[:files].length\n      end\n    end\n\n    if number_of_uploads != exp_upload_num\n      show {note \"Final number of uploads (#{number_of_uploads}) not equal to expected number #{exp_upload_num}! Please check.\"}\n      return nil\n    end\n\n    # format uploads before returning\n    ups = [] # upload hashes\n    if !uploads[:files].nil?\n      uploads[:files].each_with_index do |upload_hash, ii|\n        up = Upload.find(upload_hash[:id])\n        ups[ii] = up\n      end\n    end\n    ups\n  end\n\n  # Opens .csv file upload item using its url and stores it line by line in a matrix\n  #\n  # @param upload [upload_obj] the file that you wish to read from\n  # @return matrix [2D-Array] is the array of arrays of the rows read from file, if csv\n  def read_url(upload)\n    url = upload.url\n    matrix = []\n    CSV.new(open(url)).each { |line| matrix.push(line) }\n    # open(url).each { |line| matrix.push(line.split(',') }\n  end\n\n  # Validates upload and ensures that it is correct\n  #\n  # @param uplaod_array Array array of  uploads\n  # @param expected_num_inputs int the expected number of inputs\n  # @param csv_headers array array of expected headers\n  # @returns pass Boolean pass or fail (true is pass)\n  def validate_upload(upload_array, expected_num_inputs, csv_headers, multiple_files: true)\n    if upload_array.nil?\n      show do\n        title 'No File Attached'\n        warning 'No File Was Attached'\n      end\n      return false\n    end\n\n    fail_message = ''\n\n    if multiple_files == false\n      fail_message += 'More than one file was uploaded, ' if upload_array.length \u003e 1\n      upload = upload_array.first\n    end\n\n    csv = CSV.read(open(upload.url))\n    fail_message += 'CSV length is shorter\n        than expected, ' if csv.length - 1 \u003c expected_num_inputs\n\n    first_row = csv.first\n    # Should remove leading blank space from CSV\n    first_row[0][0] = ''\n\n    csv_headers.each do |header|\n      fail_message += \"\u003cb\u003e#{header} Header\u003c/b\u003e either does not exist or\n        is in wrong format, \" if !first_row.include?(header)\n    end\n\n    if fail_message.length \u003e 0\n      show do\n        title 'Warning Uploaded CSV does not fit correct format'\n        note \"#{fail_message}\"\n      end\n      return false\n    else\n      return true\n    end\n  end\n\n  # Needs documentation\n  def get_validated_uploads(expected_data_points, headers, multi_files, file_location: 'Unknown Location')\n    tries = 1\n    max_tries = 10\n    pass = false\n    until pass == true\n      csv_uploads = upload_csv(tries, max_tries, file_location: file_location)\n      pass = validate_upload(csv_uploads, expected_data_points, headers, multiple_files: multi_files)\n      tries += 1\n      raise 'Too many failed upload attempts' if tries == max_tries \u0026\u0026 !pass\n    end\n    csv_uploads\n  end\n\n  # Instructions to upload CSV files of concentrations\n  def upload_csv(tries = nil, max_tries = 'NA', file_location: 'Unknown Location')\n    up_csv = show do\n      title \"Upload CSV (attempts: #{tries}/#{max_tries})\"\n      note \"Please upload a \u003cb\u003eCSV\u003c/b\u003e file located at #{file_location}\"\n      upload var: CSV_KEY.to_sym\n    end\n    up_csv.get_response(CSV_KEY.to_sym)\n  end\nend\n"}},{"library":{"name":"WorkSpace","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\n# Warnings for working with BSL2 Hazards,\n# Take word for word from OLA-Simple, Vector Graphics have been removed\n# for simplicity.\nmodule WorkSpace\n  def rnase_warning\n    show do\n      title 'RNase degrades RNA'\n      note 'RNA is prone to degradation by RNase present in our eyes, skin, and breath.'\n      note 'Avoid opening tubes outside the Biosafety Cabinet (BSC).'\n      bullet 'Change gloves whenever you suspect potential RNAse contamination'\n    end\n  end\n\n  def safety_warning\n    show do\n      title 'Review Safety Warnings'\n      note '\u003cb\u003eAlways\u003c/b\u003e pay attention to orange warning blocks throughout the protocol.'\n      warning '\u003cb\u003eINFECTIOUS MATERIALS\u003c/b\u003e'\n      note 'You will be working with infectious materials.'\n      note 'Do \u003cb\u003eALL\u003c/b\u003e work in a biosafety cabinet (BSC).'\n      note '\u003cb\u003ePPE is required\u003c/b\u003e'\n      check 'Put on lab coat.'\n      check 'Put on 2 layers of gloves.'\n      bullet 'Make sure to use tight gloves. Tight gloves reduce the chance of the gloves getting caught on the tubes when closing their lids.'\n      bullet 'Change outer layer of gloves after handling infectious sample and before touching surfaces outside of the BSC (such as a refrigerator door handle).'\n    end\n  end\n\n  def clean_workspace\n    show do\n      title 'Clean Workspace'\n      note 'Clean any contaminated workspaces or work tools'\n      note 'Assume that any surface touched or tool used is contaminated'\n      note 'Using fresh paper wipe clean with:'\n      check 'Bleach'\n      check '70% EtOH'\n    end\n  end\nend\n"}}]}